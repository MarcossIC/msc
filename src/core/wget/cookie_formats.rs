// Cookie formatting utilities for various export formats

pub use super::wget_cookies::Cookie;
use anyhow::Result;

/// Convert Chrome's WebKit timestamp to Unix timestamp
///
/// # Chrome Timestamp Format
/// - Microseconds since 1601-01-01 00:00:00 UTC (Windows file time epoch)
/// - Example: 13324569600000000 = 2024-01-01 00:00:00 UTC
///
/// # Unix Timestamp Format
/// - Seconds since 1970-01-01 00:00:00 UTC
/// - Example: 1704067200 = 2024-01-01 00:00:00 UTC
///
/// # Conversion
/// 1. Subtract epoch difference: 11644473600 seconds (1601 to 1970)
/// 2. Convert microseconds to seconds: divide by 1,000,000
///
/// # Arguments
/// * `chrome_time` - Chrome timestamp in microseconds since 1601
///
/// # Returns
/// * Unix timestamp in seconds since 1970
/// * Returns 0 for expired/session cookies (chrome_time == 0)
pub fn chrome_time_to_unix(chrome_time: i64) -> i64 {
    if chrome_time == 0 {
        return 0; // Session cookie or expired
    }

    // Windows epoch (1601-01-01) to Unix epoch (1970-01-01) in microseconds
    const EPOCH_DIFF_MICROSECONDS: i64 = 11644473600000000;

    // Convert to Unix timestamp (seconds)
    (chrome_time - EPOCH_DIFF_MICROSECONDS) / 1000000
}

/// Format cookies as wget-compatible header string
///
/// # Format
/// ```text
/// name1=value1; name2=value2; name3=value3
/// ```
///
/// This format can be used directly in HTTP Cookie headers or with wget/curl.
///
/// # Example
/// ```text
/// session_id=abc123; user_pref=dark_mode; lang=en
/// ```
pub fn format_wget(cookies: &[Cookie]) -> String {
    cookies
        .iter()
        .map(|c| format!("{}={}", c.name, c.value))
        .collect::<Vec<_>>()
        .join("; ")
}

/// Format cookies in Netscape cookies.txt format (tab-separated).
///
/// This format is compatible with wget, curl, yt-dlp, aria2c,
/// and most HTTP clients supporting Netscape cookies.
pub fn format_netscape(cookies: &[Cookie]) -> String {
    let mut output = String::from(
        "# Netscape HTTP Cookie File\n\
         # https://curl.se/docs/http-cookies.html\n\
         # Generated by msc\n\n",
    );

    for cookie in cookies {
        // Domain flag: TRUE if domain starts with '.' (subdomain wildcard)
        let subdomain_flag = if cookie.domain.starts_with('.') {
            "TRUE"
        } else {
            "FALSE"
        };

        // Secure flag: TRUE for HTTPS-only
        let secure_flag = if cookie.secure { "TRUE" } else { "FALSE" };

        // Convert Chrome timestamp to Unix timestamp
        let unix_expires = chrome_time_to_unix(cookie.expires);
        let name = sanitize_field(&cookie.name);
        let value = sanitize_field(&cookie.value);

        // Write cookie line (tab-separated)
        output.push_str(&format!(
            "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
            cookie.domain, subdomain_flag, cookie.path, secure_flag, unix_expires, name, value
        ));
    }

    output
}

fn sanitize_field(value: &str) -> String {
    value.replace('\t', "").replace('\n', "")
}

/// Format cookies as JSON array
///
/// # Format
/// ```json
/// [
///   {
///     "name": "session_id",
///     "value": "abc123",
///     "domain": ".github.com",
///     "path": "/",
///     "expires": 1704067200,
///     "secure": false,
///     "httpOnly": true,
///     "sameSite": "Lax"
///   }
/// ]
/// ```
///
/// # Fields
/// - **name**: Cookie name
/// - **value**: Cookie value (decrypted)
/// - **domain**: Cookie domain
/// - **path**: Cookie path
/// - **expires**: Unix timestamp in seconds
/// - **secure**: HTTPS-only flag
/// - **httpOnly**: JavaScript access restriction
/// - **sameSite**: Same-site policy (None, Lax, Strict, Unspecified)
pub fn format_json(cookies: &[Cookie]) -> Result<String> {
    let json_cookies: Vec<serde_json::Value> = cookies
        .iter()
        .map(|c| {
            serde_json::json!({
                "name": c.name,
                "value": c.value,
                "domain": c.domain,
                "path": c.path,
                "expires": chrome_time_to_unix(c.expires),
                "secure": c.secure,
                "httpOnly": c.http_only,
                "sameSite": c.same_site,
            })
        })
        .collect();

    serde_json::to_string_pretty(&json_cookies)
        .map_err(|e| anyhow::anyhow!("Failed to serialize cookies to JSON: {}", e))
}

/// Format cookies according to the specified format
///
/// # Supported Formats
/// - **wget**, **curl**, **header**: Simple "name=value" header format
/// - **netscape**, **txt**, **mozilla**: Netscape cookies.txt format
/// - **json**: JSON array format
///
/// # Arguments
/// * `cookies` - Cookie array to format
/// * `format` - Output format (case-insensitive)
///
/// # Returns
/// * `Ok(String)` - Formatted cookie string
/// * `Err(...)` - Unsupported format
///
/// # Example
/// ```rust
/// # use anyhow::Result;
/// # use msc::core::wget::cookie_formats::{format_cookies, Cookie};
/// # fn main() -> Result<()> {
/// # let cookies = vec![Cookie {
/// #     name: "test".to_string(),
/// #     value: "value".to_string(),
/// #     domain: ".example.com".to_string(),
/// #     path: "/".to_string(),
/// #     expires: 0,
/// #     secure: false,
/// #     http_only: false,
/// #     same_site: "Lax".to_string(),
/// # }];
/// let formatted = format_cookies(&cookies, "netscape")?;
/// # Ok(())
/// # }
/// ```
pub fn format_cookies(cookies: &[Cookie], format: &str) -> Result<String> {
    match format.to_lowercase().as_str() {
        "wget" | "curl" | "header" => Ok(format_wget(cookies)),
        "netscape" | "txt" | "mozilla" => Ok(format_netscape(cookies)),
        "json" => format_json(cookies),
        _ => Err(anyhow::anyhow!(
            "Unsupported format: {}\nSupported: wget, netscape, json",
            format
        )),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chrome_time_to_unix() {
        // Chrome time for 2024-01-01 00:00:00 UTC
        // Unix: 1704067200 seconds since 1970
        // Chrome: (1704067200 * 1000000) + 11644473600000000 = 13348540800000000
        let chrome_time = 13348540800000000i64;
        let unix_time = chrome_time_to_unix(chrome_time);
        assert_eq!(unix_time, 1704067200);

        // Session cookie (expires = 0)
        assert_eq!(chrome_time_to_unix(0), 0);
    }

    #[test]
    fn test_chrome_time_to_unix_edge_cases() {
        // Test various edge cases for timestamp conversion

        // Unix epoch 1970-01-01 00:00:00
        // Chrome time = 11644473600000000 (exactly the epoch difference)
        let unix_epoch_chrome = 11644473600000000i64;
        assert_eq!(chrome_time_to_unix(unix_epoch_chrome), 0);

        // Far future date: 2075-01-01 00:00:00 UTC
        // Unix: 3313526400
        // Chrome: (3313526400 * 1000000) + 11644473600000000 = 14958000000000000
        let future_chrome_time = 14958000000000000i64;
        let unix_time = chrome_time_to_unix(future_chrome_time);
        assert!(unix_time > 0);
        assert_eq!(unix_time, 3313526400);

        // Negative values should still work (though unusual)
        // -1 microseconds since 1601 = (-1 - 11644473600000000) / 1000000
        assert_eq!(chrome_time_to_unix(-1), -11644473600);
    }

    #[test]
    fn test_format_wget() {
        let cookies = vec![
            Cookie {
                name: "session".to_string(),
                value: "abc123".to_string(),
                domain: ".github.com".to_string(),
                path: "/".to_string(),
                expires: 0,
                secure: false,
                http_only: true,
                same_site: "Lax".to_string(),
            },
            Cookie {
                name: "pref".to_string(),
                value: "dark".to_string(),
                domain: ".github.com".to_string(),
                path: "/".to_string(),
                expires: 0,
                secure: true,
                http_only: false,
                same_site: "None".to_string(),
            },
        ];

        let result = format_wget(&cookies);
        assert_eq!(result, "session=abc123; pref=dark");
    }

    #[test]
    fn test_format_wget_empty() {
        // Test with no cookies
        let cookies: Vec<Cookie> = vec![];
        let result = format_wget(&cookies);
        assert_eq!(result, "");
    }

    #[test]
    fn test_format_wget_single() {
        // Test with single cookie
        let cookies = vec![Cookie {
            name: "single".to_string(),
            value: "value".to_string(),
            domain: "example.com".to_string(),
            path: "/".to_string(),
            expires: 0,
            secure: false,
            http_only: false,
            same_site: "Lax".to_string(),
        }];

        let result = format_wget(&cookies);
        assert_eq!(result, "single=value");
    }

    #[test]
    fn test_format_wget_special_characters() {
        // Test cookies with special characters in values
        let cookies = vec![Cookie {
            name: "encoded".to_string(),
            value: "value%20with%20spaces".to_string(),
            domain: "example.com".to_string(),
            path: "/".to_string(),
            expires: 0,
            secure: false,
            http_only: false,
            same_site: "Lax".to_string(),
        }];

        let result = format_wget(&cookies);
        assert_eq!(result, "encoded=value%20with%20spaces");
    }

    #[test]
    fn test_format_netscape() {
        let cookies = vec![Cookie {
            name: "test".to_string(),
            value: "value123".to_string(),
            domain: ".example.com".to_string(),
            path: "/".to_string(),
            expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
            secure: false,
            http_only: true,
            same_site: "Lax".to_string(),
        }];

        let result = format_netscape(&cookies);
        assert!(result.contains("# Netscape HTTP Cookie File"));
        assert!(result.contains(".example.com\tTRUE\t/\tFALSE\t1704067200\ttest\tvalue123"));
    }

    #[test]
    fn test_format_netscape_subdomain_flags() {
        let cookies = vec![
            // Cookie with leading dot (subdomain wildcard)
            Cookie {
                name: "wildcard".to_string(),
                value: "yes".to_string(),
                domain: ".example.com".to_string(),
                path: "/".to_string(),
                expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
                secure: false,
                http_only: false,
                same_site: "Lax".to_string(),
            },
            // Cookie without leading dot (exact domain)
            Cookie {
                name: "exact".to_string(),
                value: "no".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
                secure: false,
                http_only: false,
                same_site: "Lax".to_string(),
            },
        ];

        let result = format_netscape(&cookies);

        // First cookie should have TRUE subdomain flag
        assert!(result.contains(".example.com\tTRUE\t"));

        // Second cookie should have FALSE subdomain flag
        assert!(result.contains("example.com\tFALSE\t"));
    }

    #[test]
    fn test_format_netscape_secure_flags() {
        let cookies = vec![
            // Secure cookie
            Cookie {
                name: "secure_cookie".to_string(),
                value: "encrypted".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
                secure: true,
                http_only: false,
                same_site: "Lax".to_string(),
            },
            // Non-secure cookie
            Cookie {
                name: "plain_cookie".to_string(),
                value: "plain".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
                secure: false,
                http_only: false,
                same_site: "Lax".to_string(),
            },
        ];

        let result = format_netscape(&cookies);

        // Secure cookie should have TRUE in secure position
        assert!(result.contains("secure_cookie") && result.contains("\tTRUE\t1704067200\t"));

        // Non-secure cookie should have FALSE in secure position
        assert!(result.contains("plain_cookie") && result.contains("\tFALSE\t1704067200\t"));
    }

    #[test]
    fn test_sanitize_field() {
        // Test sanitization of tabs and newlines
        let dirty = "value\twith\ttabs\nand\nnewlines";
        let clean = sanitize_field(dirty);

        assert!(!clean.contains('\t'));
        assert!(!clean.contains('\n'));
        assert_eq!(clean, "valuewithtabsandnewlines");
    }

    #[test]
    fn test_format_netscape_sanitizes_values() {
        // Test that cookie values with tabs/newlines are sanitized
        let cookies = vec![Cookie {
            name: "dirty\tname".to_string(),
            value: "dirty\nvalue".to_string(),
            domain: "example.com".to_string(),
            path: "/".to_string(),
            expires: 0,
            secure: false,
            http_only: false,
            same_site: "Lax".to_string(),
        }];

        let result = format_netscape(&cookies);

        // Should not contain raw tabs or newlines in cookie data
        let lines: Vec<&str> = result.lines().collect();
        let cookie_line = lines.iter().find(|l| l.contains("dirtyname")).unwrap();

        assert!(!cookie_line.contains("dirty\tname"));
        assert!(!cookie_line.contains("dirty\nvalue"));
    }

    #[test]
    fn test_format_json() {
        let cookies = vec![Cookie {
            name: "auth".to_string(),
            value: "token".to_string(),
            domain: "example.com".to_string(),
            path: "/api".to_string(),
            expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
            secure: true,
            http_only: true,
            same_site: "Strict".to_string(),
        }];

        let result = format_json(&cookies).unwrap();
        assert!(result.contains("\"name\": \"auth\""));
        assert!(result.contains("\"value\": \"token\""));
        assert!(result.contains("\"httpOnly\": true"));
        assert!(result.contains("\"sameSite\": \"Strict\""));
    }

    #[test]
    fn test_format_json_empty() {
        // Test JSON formatting with empty array
        let cookies: Vec<Cookie> = vec![];
        let result = format_json(&cookies).unwrap();

        assert_eq!(result, "[]");
    }

    #[test]
    fn test_format_json_all_same_site_values() {
        // Test all possible SameSite values
        let cookies = vec![
            Cookie {
                name: "none".to_string(),
                value: "val".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 0,
                secure: true,
                http_only: false,
                same_site: "None".to_string(),
            },
            Cookie {
                name: "lax".to_string(),
                value: "val".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 0,
                secure: false,
                http_only: false,
                same_site: "Lax".to_string(),
            },
            Cookie {
                name: "strict".to_string(),
                value: "val".to_string(),
                domain: "example.com".to_string(),
                path: "/".to_string(),
                expires: 0,
                secure: false,
                http_only: false,
                same_site: "Strict".to_string(),
            },
        ];

        let result = format_json(&cookies).unwrap();

        assert!(result.contains("\"sameSite\": \"None\""));
        assert!(result.contains("\"sameSite\": \"Lax\""));
        assert!(result.contains("\"sameSite\": \"Strict\""));
    }

    #[test]
    fn test_format_json_timestamp_conversion() {
        // Verify that Chrome timestamps are converted to Unix in JSON
        let cookies = vec![Cookie {
            name: "timed".to_string(),
            value: "val".to_string(),
            domain: "example.com".to_string(),
            path: "/".to_string(),
            expires: 13348540800000000, // Chrome timestamp for 2024-01-01 00:00:00 UTC
            secure: false,
            http_only: false,
            same_site: "Lax".to_string(),
        }];

        let result = format_json(&cookies).unwrap();

        // Should contain Unix timestamp (1704067200), not Chrome timestamp
        assert!(result.contains("\"expires\": 1704067200"));
        assert!(!result.contains("13348540800000000"));
    }

    #[test]
    fn test_format_cookies_dispatcher() {
        let cookies = vec![Cookie {
            name: "test".to_string(),
            value: "val".to_string(),
            domain: ".example.com".to_string(),
            path: "/".to_string(),
            expires: 0,
            secure: false,
            http_only: false,
            same_site: "None".to_string(),
        }];

        // Test wget format and aliases
        assert!(format_cookies(&cookies, "wget").is_ok());
        assert!(format_cookies(&cookies, "WGET").is_ok()); // Case insensitive
        assert!(format_cookies(&cookies, "curl").is_ok()); // Alias
        assert!(format_cookies(&cookies, "header").is_ok()); // Alias

        // Test netscape format and aliases
        assert!(format_cookies(&cookies, "netscape").is_ok());
        assert!(format_cookies(&cookies, "txt").is_ok()); // Alias
        assert!(format_cookies(&cookies, "mozilla").is_ok()); // Alias

        // Test json format
        assert!(format_cookies(&cookies, "json").is_ok());
        assert!(format_cookies(&cookies, "JSON").is_ok()); // Case insensitive

        // Test unsupported format
        let result = format_cookies(&cookies, "xml");
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Unsupported format"));
    }

    #[test]
    fn test_format_cookies_output_consistency() {
        // Verify that format_cookies dispatcher produces same output as direct calls
        let cookies = vec![Cookie {
            name: "test".to_string(),
            value: "value".to_string(),
            domain: "example.com".to_string(),
            path: "/".to_string(),
            expires: 13348540800000000, // 2024-01-01 00:00:00 UTC
            secure: true,
            http_only: true,
            same_site: "Strict".to_string(),
        }];

        // wget format
        let direct_wget = format_wget(&cookies);
        let dispatcher_wget = format_cookies(&cookies, "wget").unwrap();
        assert_eq!(direct_wget, dispatcher_wget);

        // netscape format
        let direct_netscape = format_netscape(&cookies);
        let dispatcher_netscape = format_cookies(&cookies, "netscape").unwrap();
        assert_eq!(direct_netscape, dispatcher_netscape);

        // json format
        let direct_json = format_json(&cookies).unwrap();
        let dispatcher_json = format_cookies(&cookies, "json").unwrap();
        assert_eq!(direct_json, dispatcher_json);
    }
}
