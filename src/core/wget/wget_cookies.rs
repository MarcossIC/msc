use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use rusqlite::Connection;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use url::Url;

use super::chrome_decrypt::ChromeDecryptor;
use super::chrome_manager::ChromeManager;
// use super::cdp_cookies;
// use super::chrome_launcher::ChromeInstance;

/// Cookie structure for extraction
#[derive(Debug, Clone)]
pub struct Cookie {
    pub name: String,
    pub value: String,
    pub domain: String,
    pub path: String,
    pub expires: i64,
    pub secure: bool,
    pub http_only: bool,
    pub same_site: String,
}

/// Create a cookie file in Netscape format from a cookie string
pub fn create_cookie_file(url: &Url, cookie_str: &str) -> Result<PathBuf> {
    let domain = url.domain().context("URL must have a domain")?;

    // Create temp directory if it doesn't exist
    let temp_dir = env::temp_dir();
    let cookie_file = temp_dir.join(format!("msc_cookies_{}.txt", std::process::id()));

    let mut file = fs::File::create(&cookie_file)
        .with_context(|| format!("Failed to create cookie file: {}", cookie_file.display()))?;

    // Write Netscape cookie file header
    writeln!(file, "# Netscape HTTP Cookie File")?;
    writeln!(
        file,
        "# This file was generated by msc. Edit at your own risk."
    )?;
    writeln!(file)?;

    // Parse cookies from the string format: "name1=value1; name2=value2"
    for cookie_pair in cookie_str.split(';') {
        let cookie_pair = cookie_pair.trim();
        if cookie_pair.is_empty() {
            continue;
        }

        let parts: Vec<&str> = cookie_pair.splitn(2, '=').collect();
        if parts.len() != 2 {
            println!(
                "{}",
                format!("‚ö†Ô∏è  Cookie inv√°lida (ignorada): {}", cookie_pair).yellow()
            );
            continue;
        }

        let name = parts[0].trim();
        let value = parts[1].trim();

        // Netscape cookie format:
        // domain    flag    path    secure    expiration    name    value
        // flag: TRUE for domain cookies, FALSE for host-only
        // secure: TRUE for HTTPS only, FALSE for any
        // expiration: Unix timestamp (we use far future: year 2038)

        // Use .domain to match all subdomains
        let cookie_domain = format!(".{}", domain);
        let expiration = 2147483647; // Max 32-bit Unix timestamp (2038-01-19)

        // Write cookie line
        writeln!(
            file,
            "{}\tTRUE\t/\tFALSE\t{}\t{}\t{}",
            cookie_domain, expiration, name, value
        )?;
    }

    file.flush()?;

    println!(
        "{}",
        format!("   ‚úì Archivo de cookies creado: {}", cookie_file.display()).dimmed()
    );

    Ok(cookie_file)
}

/// Find browser cookie database path
pub fn find_browser_cookie_db(browser: &str) -> Result<PathBuf> {
    let app_data = if cfg!(windows) {
        env::var("LOCALAPPDATA").context("LOCALAPPDATA no est√° configurado")?
    } else if cfg!(target_os = "macos") {
        let home = env::var("HOME").context("HOME no est√° configurado")?;
        format!("{}/Library/Application Support", home)
    } else {
        let home = env::var("HOME").context("HOME no est√° configurado")?;
        format!("{}/.config", home)
    };

    let cookie_path = match browser.to_lowercase().as_str() {
        "chrome" | "google-chrome" => {
            if cfg!(windows) {
                PathBuf::from(app_data).join("Google\\Chrome\\User Data\\Default\\Network\\Cookies")
            } else if cfg!(target_os = "macos") {
                PathBuf::from(app_data).join("Google/Chrome/Default/Cookies")
            } else {
                PathBuf::from(app_data).join("google-chrome/Default/Cookies")
            }
        }
        "edge" | "msedge" => {
            if cfg!(windows) {
                PathBuf::from(app_data)
                    .join("Microsoft\\Edge\\User Data\\Default\\Network\\Cookies")
            } else if cfg!(target_os = "macos") {
                PathBuf::from(app_data).join("Microsoft Edge/Default/Cookies")
            } else {
                PathBuf::from(app_data).join("microsoft-edge/Default/Cookies")
            }
        }
        "firefox" => {
            // Firefox uses a different structure with profiles
            if cfg!(windows) {
                let roaming = env::var("APPDATA").context("APPDATA no est√° configurado")?;
                let profiles_dir = PathBuf::from(roaming).join("Mozilla\\Firefox\\Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else if cfg!(target_os = "macos") {
                let home = env::var("HOME").context("HOME no est√° configurado")?;
                let profiles_dir =
                    PathBuf::from(home).join("Library/Application Support/Firefox/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else {
                let profiles_dir = PathBuf::from(app_data).join("firefox/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            }
        }
        "librewolf" => {
            // LibreWolf is a Firefox fork with different directory structure
            if cfg!(windows) {
                let roaming = env::var("APPDATA").context("APPDATA no est√° configurado")?;
                let profiles_dir = PathBuf::from(roaming).join("librewolf\\Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else if cfg!(target_os = "macos") {
                let home = env::var("HOME").context("HOME no est√° configurado")?;
                let profiles_dir =
                    PathBuf::from(home).join("Library/Application Support/librewolf/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else {
                let profiles_dir = PathBuf::from(app_data).join("librewolf/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            }
        }
        "brave" => {
            if cfg!(windows) {
                PathBuf::from(app_data)
                    .join("BraveSoftware\\Brave-Browser\\User Data\\Default\\Network\\Cookies")
            } else {
                PathBuf::from(app_data).join("BraveSoftware/Brave-Browser/Default/Cookies")
            }
        }
        _ => {
            return Err(anyhow!(
                "Navegador no soportado: {}. Usa: chrome, firefox, librewolf, edge, brave",
                browser
            ))
        }
    };

    if !cookie_path.exists() {
        return Err(anyhow!(
            "No se encontr√≥ la base de datos de cookies en: {}\n\
            Aseg√∫rate de que:\n\
            ‚Ä¢ El navegador est√© instalado\n\
            ‚Ä¢ Has usado el navegador al menos una vez\n\
            ‚Ä¢ La ruta del perfil es correcta",
            cookie_path.display()
        ));
    }

    Ok(cookie_path)
}

/// Find Firefox cookie database (cookies.sqlite)
pub fn find_firefox_cookie_db(profiles_dir: &Path) -> Result<PathBuf> {
    let entries = fs::read_dir(profiles_dir).with_context(|| {
        format!(
            "No se pudo leer el directorio de perfiles: {}",
            profiles_dir.display()
        )
    })?;

    // Find the first .default or .default-release profile
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        if !path.is_dir() {
            continue;
        }

        let dir_name = match path.file_name() {
            Some(name) => name.to_string_lossy(),
            None => continue,
        };

        if dir_name.contains(".default") || dir_name.contains(".default-release") {
            let cookie_file = path.join("cookies.sqlite");
            if cookie_file.exists() {
                return Ok(cookie_file);
            }
        }
    }

    Err(anyhow!(
        "No se encontr√≥ 'cookies.sqlite' en ning√∫n perfil v√°lido dentro de: {}",
        profiles_dir.display()
    ))
}

/// Extract cookies from browser database
pub fn extract_cookies_from_db(db_path: &Path, domain: &str) -> Result<Vec<Cookie>> {
    // Create a temporary copy of the database because browsers lock it
    let temp_db = env::temp_dir().join(format!("msc_cookies_temp_{}.db", std::process::id()));

    // Copy main database file
    fs::copy(db_path, &temp_db).context("No se pudo copiar la base de datos de cookies. Aseg√∫rate de que el navegador est√© cerrado.")?;

    // Check for WAL (Write-Ahead Logging) files - these contain recent changes when browser is open
    let wal_path = db_path.with_extension("sqlite-wal");
    let shm_path = db_path.with_extension("sqlite-shm");

    let temp_wal = temp_db.with_extension("sqlite-wal");
    let temp_shm = temp_db.with_extension("sqlite-shm");

    // Copy WAL files if they exist (browser is open)
    if wal_path.exists() && fs::copy(&wal_path, &temp_wal).is_ok() {
        println!(
            "{}",
            "   ‚ÑπÔ∏è  Navegador abierto detectado, leyendo archivo WAL...".yellow()
        );
    }

    if shm_path.exists() {
        let _ = fs::copy(&shm_path, &temp_shm);
    }

    let conn =
        Connection::open(&temp_db).context("No se pudo abrir la base de datos de cookies")?;

    let mut cookies = Vec::new();

    // Detect if this is a Chromium-based browser (needs decryption)
    let is_chromium = db_path
        .to_str()
        .map(|s| {
            let s_lower = s.to_lowercase();
            s_lower.contains("chrome")
                || s_lower.contains("edge")
                || s_lower.contains("brave")
                || s_lower.contains("chromium")
        })
        .unwrap_or(false);

    // Initialize decryptor for Chromium browsers
    let decryptor = if is_chromium {
        // Try to detect browser name from path
        let browser_name = db_path
            .to_str()
            .and_then(|s| {
                let s_lower = s.to_lowercase();
                if s_lower.contains("edge") {
                    Some("edge")
                } else if s_lower.contains("brave") {
                    Some("brave")
                } else if s_lower.contains("chromium") {
                    Some("chromium")
                } else if s_lower.contains("chrome") {
                    Some("chrome")
                } else {
                    None
                }
            })
            .unwrap_or("chrome");

        match ChromeDecryptor::new(browser_name) {
            Ok(dec) => Some(dec),
            Err(e) => {
                // Check for App-Bound Encryption (Chrome 127+)
                if e.to_string().contains("App-Bound") {
                    return Err(anyhow!(
                        "Chrome 127+ detectado con 'App-Bound Encryption'.\n\
                        Esta versi√≥n de Chrome requiere permisos especiales de sistema para desencriptar cookies via archivo.\n\n\
                        SOLUCI√ìN:\n\
                        Usa el flag --auto-launch para extraer las cookies via Protocolo de Chrome (CDP).\n\n\
                        IMPORTANTE:\n\
                        Debes cerrar TODAS las ventanas de Chrome antes de ejecutar el comando con --auto-launch.\n\n\
                        Ejemplo:\n\
                        msc wget cookies google.com --auto-launch"
                    ));
                }

                eprintln!("‚ö†Ô∏è  No se pudo inicializar desencriptaci√≥n: {}", e);
                eprintln!("   Se intentar√° extraer cookies sin desencriptar (solo funcionar√° para cookies muy antiguas).");
                None
            }
        }
    } else {
        None
    };

    // Try Chrome/Edge/Brave schema first
    let chrome_query = "SELECT name, value, encrypted_value, host_key, path, expires_utc, is_secure, is_httponly, samesite FROM cookies WHERE host_key LIKE ?1 OR host_key LIKE ?2 OR host_key = ?3";

    // Patterns for matching domains:
    // 1. .domain.com (subdomain wildcard)
    // 2. domain.com (exact match)
    // 3. www.domain.com (common www variant)

    let clean_domain = domain.strip_prefix("www.").unwrap_or(domain);

    let dot_domain_pattern = format!(".{}", clean_domain);
    let exact_domain_pattern = clean_domain.to_string();
    let www_domain_pattern = format!("www.{}", clean_domain);

    if let Ok(mut stmt) = conn.prepare(chrome_query) {
        let cookie_iter = stmt.query_map(
            [
                &dot_domain_pattern,
                &exact_domain_pattern,
                &www_domain_pattern,
            ],
            |row| {
                // Extract all fields as raw values
                Ok((
                    row.get::<_, String>(0)?,     // name
                    row.get::<_, String>(1)?,     // value
                    row.get::<_, Vec<u8>>(2)?,    // encrypted_value
                    row.get::<_, String>(3)?,     // host_key (domain)
                    row.get::<_, String>(4)?,     // path
                    row.get::<_, i64>(5)?,        // expires_utc
                    row.get::<_, i64>(6)? != 0,   // is_secure
                    row.get::<_, i64>(7)? != 0,   // is_httponly
                    row.get::<_, i64>(8)?,        // samesite
                ))
            },
        )?;

        // Process cookies with decryption
        for (name, value, encrypted_value, domain, path, expires, secure, http_only, same_site_int) in cookie_iter.flatten() {
            let final_value = match resolve_cookie_value(
                &name,
                value,
                encrypted_value,
                &decryptor,
            ) {
                Some(v) => v,
                None => continue,
            };

            cookies.push(Cookie {
                name,
                value: final_value,
                domain,
                path,
                expires,
                secure,
                http_only,
                same_site: same_site_from_int(same_site_int).to_string(),
            });
        }
    } else {
        // Try Firefox schema - match .domain.com, domain.com, or www.domain.com
        let firefox_query = "SELECT name, value, host, path, expiry, isSecure, COALESCE(isHttpOnly, 0), COALESCE(sameSite, -1) FROM moz_cookies WHERE host = ?1 OR host = ?2 OR host = ?3";

        if let Ok(mut stmt) = conn.prepare(firefox_query) {
            let cookie_iter = stmt.query_map(
                [
                    &dot_domain_pattern,
                    &exact_domain_pattern,
                    &www_domain_pattern,
                ],
                |row| {
                    let http_only = row.get::<_, i64>(6)? != 0;
                    let same_site_int = row.get::<_, i64>(7)?;

                    let same_site = match same_site_int {
                        0 => "None",
                        1 => "Lax",
                        2 => "Strict",
                        -1 => "Unspecified", // COALESCE default
                        _ => "Unspecified",
                    }
                    .to_string();

                    Ok(Cookie {
                        name: row.get(0)?,
                        value: row.get(1)?,
                        domain: row.get(2)?,
                        path: row.get(3)?,
                        expires: row.get(4)?,
                        secure: row.get::<_, i64>(5)? != 0,
                        http_only,
                        same_site,
                    })
                },
            )?;

            for cookie in cookie_iter.flatten() {
                cookies.push(cookie);
            }

            // If no cookies found, try to debug by showing what hosts exist
            if cookies.is_empty() {
                eprintln!();
                eprintln!(
                    "{}",
                    "üîç Debug: No se encontraron cookies con el patr√≥n de b√∫squeda.".yellow()
                );
                eprintln!(
                    "{}",
                    format!(
                        "   Buscando: '{}' o '{}'",
                        exact_domain_pattern, dot_domain_pattern
                    )
                    .dimmed()
                );
                eprintln!();
                eprintln!(
                    "{}",
                    "   Mostrando todos los hosts en la base de datos:".dimmed()
                );

                if let Ok(mut stmt) = conn.prepare("SELECT DISTINCT host FROM moz_cookies LIMIT 20")
                {
                    let hosts: Vec<String> =
                        stmt.query_map([], |row| row.get(0))?.flatten().collect();
                    for host in hosts {
                        eprintln!("     ‚Ä¢ {}", host.cyan());
                    }
                }
                eprintln!();
            }
        }
    }

    // Clean up temp files
    let _ = fs::remove_file(&temp_db);
    let _ = fs::remove_file(&temp_wal);
    let _ = fs::remove_file(&temp_shm);

    Ok(cookies)
}


fn same_site_from_int(value: i64) -> &'static str {
    match value {
        0 => "None",
        1 => "Lax",
        2 => "Strict",
        _ => "Unspecified",
    }
}

fn resolve_cookie_value(
    name: &str,
    value: String,
    encrypted_value: Vec<u8>,
    decryptor: &Option<ChromeDecryptor>,
) -> Option<String> {
    if !value.is_empty() {
        return Some(value);
    }

    if encrypted_value.is_empty() {
        return None;
    }

    let decryptor = decryptor.as_ref()?;

    match decryptor.decrypt_cookie_value(&encrypted_value) {
        Ok(decrypted) => Some(decrypted),
        Err(e) => {
            eprintln!("‚ö†Ô∏è  Cookie '{}': {}", name, e);
            None
        }
    }
}

/// Extract cookies with intelligent multi-strategy approach
///
/// This is the NEW smart extraction function that replaces the old CDP logic.
/// It uses ChromeManager for intelligent fallback and better error handling.
///
/// # Strategy (Automatic Fallback)
/// 1. Detect Chrome state (running with/without CDP, or not running)
/// 2. Choose best extraction strategy based on flags and state
/// 3. Execute with automatic fallback to alternative methods
/// 4. Provide clear, actionable error messages on failure
///
/// # Arguments
/// * `domain` - Domain to extract cookies from
/// * `db_path` - Path to browser cookie database
/// * `use_cdp` - Force CDP usage (--cdp flag)
/// * `auto_launch` - Launch Chrome with CDP if needed (--auto-launch flag)
///
/// # Returns
/// * `Ok(Vec<Cookie>)` - Extracted cookies
/// * `Err(...)` - All strategies failed with helpful error message
pub async fn extract_cookies_with_cdp(
    domain: &str,
    db_path: &Path,
    use_cdp: bool,
    auto_launch: bool,
) -> Result<Vec<Cookie>> {
    let path = db_path
        .to_string_lossy()
        .to_lowercase();

    let browser_type = if path.contains("edge") {
        "edge"
    } else if path.contains("brave") {
        "brave"
    } else if path.contains("chrome") {
        "chrome"
    } else {
        // Non-Chromium browser (e.g. Firefox)
        return extract_cookies_from_db(db_path, domain);
    };

    // Use the new ChromeManager for intelligent extraction
    let manager = ChromeManager::new(browser_type, db_path.to_path_buf());
    manager
        .extract_cookies_smart(domain, use_cdp, auto_launch)
        .await
}

/// Format cookies in different formats
///
/// This function delegates to the cookie_formats module for actual formatting.
/// Maintained for backward compatibility.
///
/// # Arguments
/// * `cookies` - Cookie array to format
/// * `format` - Output format: "wget", "netscape", or "json"
/// * `_domain` - Unused (kept for backward compatibility)
pub fn format_cookies(cookies: &[Cookie], format: &str, _domain: &str) -> Result<String> {
    // Delegate to cookie_formats module
    super::cookie_formats::format_cookies(cookies, format)
}

/// Debug database information - shows schema and sample data
pub fn debug_database_info(db_path: &Path) -> Result<()> {
    println!("{}", "üîç INFORMACI√ìN DE LA BASE DE DATOS".cyan().bold());
    println!("{}", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".cyan());
    println!();

    // Create temporary copy
    let temp_db = env::temp_dir().join(format!("msc_debug_{}.db", std::process::id()));
    fs::copy(db_path, &temp_db)?;

    // Copy WAL files if they exist
    let wal_path = db_path.with_extension("sqlite-wal");
    let shm_path = db_path.with_extension("sqlite-shm");
    let temp_wal = temp_db.with_extension("sqlite-wal");
    let temp_shm = temp_db.with_extension("sqlite-shm");

    if wal_path.exists() {
        let _ = fs::copy(&wal_path, &temp_wal);
    }
    if shm_path.exists() {
        let _ = fs::copy(&shm_path, &temp_shm);
    }

    let conn = Connection::open(&temp_db)?;

    // 1. List all tables
    println!("{}", "üìä TABLAS EN LA BASE DE DATOS:".green().bold());
    let mut stmt =
        conn.prepare("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")?;
    let tables: Vec<String> = stmt.query_map([], |row| row.get(0))?.flatten().collect();

    for table in &tables {
        println!("   ‚Ä¢ {}", table.cyan());
    }
    println!();

    // 2. Find cookie-related tables
    let cookie_tables: Vec<&String> = tables
        .iter()
        .filter(|t| t.to_lowercase().contains("cookie"))
        .collect();

    if cookie_tables.is_empty() {
        println!(
            "{}",
            "‚ö†Ô∏è  No se encontraron tablas relacionadas con cookies".yellow()
        );
        println!();
    } else {
        for table_name in cookie_tables {
            println!(
                "{} {}",
                "üìã ESQUEMA DE LA TABLA:".green().bold(),
                table_name.cyan()
            );

            // Get table schema
            let mut stmt = conn.prepare(&format!("PRAGMA table_info({})", table_name))?;
            let columns: Vec<(i32, String, String)> = stmt
                .query_map([], |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?)))?
                .flatten()
                .collect();

            println!("{}", "   Columnas:".dimmed());
            for (_, col_name, col_type) in &columns {
                println!("   ‚Ä¢ {} ({})", col_name.cyan(), col_type.dimmed());
            }
            println!();

            // Count total rows
            let count: i64 =
                conn.query_row(&format!("SELECT COUNT(*) FROM {}", table_name), [], |row| {
                    row.get(0)
                })?;
            println!(
                "{} {}",
                "   Total de filas:".dimmed(),
                count.to_string().yellow()
            );
            println!();

            // Show sample data (first 5 rows)
            if count > 0 {
                println!("{}", "   üìù MUESTRA DE DATOS (primeras 5 filas):".dimmed());
                let column_names: Vec<String> =
                    columns.iter().map(|(_, name, _)| name.clone()).collect();

                let query = format!("SELECT * FROM {} LIMIT 5", table_name);
                let mut stmt = conn.prepare(&query)?;

                let mut rows = stmt.query([])?;
                let mut row_num = 1;

                while let Some(row) = rows.next()? {
                    println!();
                    println!("   {} {}", "Fila".dimmed(), row_num.to_string().yellow());
                    for (i, col_name) in column_names.iter().enumerate() {
                        let value: Result<String, _> = row.get(i);
                        let display_value = match value {
                            Ok(v) => {
                                if v.len() > 50 {
                                    format!("{}... ({} chars)", &v[..50], v.len())
                                } else {
                                    v
                                }
                            }
                            Err(_) => {
                                // Try as integer
                                if let Ok(v) = row.get::<_, i64>(i) {
                                    v.to_string()
                                } else {
                                    "<NULL>".to_string()
                                }
                            }
                        };
                        println!("     {}: {}", col_name.cyan(), display_value);
                    }
                    row_num += 1;
                }
                println!();
            }

            // Show some specific domain queries
            println!("{}", "   üîç B√öSQUEDA DE DOMINIOS POPULARES:".dimmed());
            let test_domains = vec!["google", "youtube", "github"];

            for test_domain in test_domains {
                // Try different column names
                let queries = vec![
                    format!(
                        "SELECT COUNT(*) FROM {} WHERE host LIKE '%{}%'",
                        table_name, test_domain
                    ),
                    format!(
                        "SELECT COUNT(*) FROM {} WHERE host_key LIKE '%{}%'",
                        table_name, test_domain
                    ),
                    format!(
                        "SELECT COUNT(*) FROM {} WHERE domain LIKE '%{}%'",
                        table_name, test_domain
                    ),
                ];

                for query in queries {
                    if let Ok(count) = conn.query_row(&query, [], |row| row.get::<_, i64>(0)) {
                        if count > 0 {
                            println!(
                                "     ‚Ä¢ {}: {} cookies",
                                test_domain.yellow(),
                                count.to_string().green()
                            );
                            break;
                        }
                    }
                }
            }
            println!();
        }
    }

    // Clean up
    let _ = fs::remove_file(&temp_db);
    let _ = fs::remove_file(&temp_wal);
    let _ = fs::remove_file(&temp_shm);

    println!("{}", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".cyan());
    println!();

    Ok(())
}

pub fn resolve_cookie_path(url: &str, cookies: Option<&str>) -> Result<Option<PathBuf>> {
    match cookies {
        Some(cookie_input) => {
            let path = PathBuf::from(cookie_input);
            if path.exists() && path.is_file() {
                println!(
                    "{} {}",
                    "üç™ Cookies:".cyan(),
                    "Archivo local cargado".green()
                );
                Ok(Some(path))
            } else {
                // Asumimos que create_cookie_file existe en tu contexto
                let url_parsed = Url::parse(url).context("URL inv√°lida para cookies")?;
                let file = create_cookie_file(&url_parsed, cookie_input)?;
                println!(
                    "{} {}",
                    "üç™ Cookies:".cyan(),
                    "String configurado temporalmente".green()
                );
                Ok(Some(file))
            }
        }
        None => Ok(None),
    }
}
