use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use rusqlite::Connection;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use url::Url;

/// Cookie structure for extraction
#[derive(Debug, Clone)]
pub struct Cookie {
    pub name: String,
    pub value: String,
    pub domain: String,
    pub path: String,
    pub expires: i64,
    pub secure: bool,
}

/// Create a cookie file in Netscape format from a cookie string
pub fn create_cookie_file(url: &Url, cookie_str: &str) -> Result<PathBuf> {
    let domain = url.domain().context("URL must have a domain")?;

    // Create temp directory if it doesn't exist
    let temp_dir = env::temp_dir();
    let cookie_file = temp_dir.join(format!("msc_cookies_{}.txt", std::process::id()));

    let mut file = fs::File::create(&cookie_file)
        .with_context(|| format!("Failed to create cookie file: {}", cookie_file.display()))?;

    // Write Netscape cookie file header
    writeln!(file, "# Netscape HTTP Cookie File")?;
    writeln!(file, "# This file was generated by msc. Edit at your own risk.")?;
    writeln!(file)?;

    // Parse cookies from the string format: "name1=value1; name2=value2"
    for cookie_pair in cookie_str.split(';') {
        let cookie_pair = cookie_pair.trim();
        if cookie_pair.is_empty() {
            continue;
        }

        let parts: Vec<&str> = cookie_pair.splitn(2, '=').collect();
        if parts.len() != 2 {
            println!(
                "{}",
                format!("‚ö†Ô∏è  Cookie inv√°lida (ignorada): {}", cookie_pair).yellow()
            );
            continue;
        }

        let name = parts[0].trim();
        let value = parts[1].trim();

        // Netscape cookie format:
        // domain    flag    path    secure    expiration    name    value
        // flag: TRUE for domain cookies, FALSE for host-only
        // secure: TRUE for HTTPS only, FALSE for any
        // expiration: Unix timestamp (we use far future: year 2038)

        // Use .domain to match all subdomains
        let cookie_domain = format!(".{}", domain);
        let expiration = 2147483647; // Max 32-bit Unix timestamp (2038-01-19)

        // Write cookie line
        writeln!(
            file,
            "{}\tTRUE\t/\tFALSE\t{}\t{}\t{}",
            cookie_domain, expiration, name, value
        )?;
    }

    file.flush()?;

    println!(
        "{}",
        format!("   ‚úì Archivo de cookies creado: {}", cookie_file.display()).dimmed()
    );

    Ok(cookie_file)
}

/// Find browser cookie database path
pub fn find_browser_cookie_db(browser: &str) -> Result<PathBuf> {
    let app_data = if cfg!(windows) {
        env::var("LOCALAPPDATA").context("LOCALAPPDATA no est√° configurado")?
    } else if cfg!(target_os = "macos") {
        let home = env::var("HOME").context("HOME no est√° configurado")?;
        format!("{}/Library/Application Support", home)
    } else {
        let home = env::var("HOME").context("HOME no est√° configurado")?;
        format!("{}/.config", home)
    };

    let cookie_path = match browser.to_lowercase().as_str() {
        "chrome" | "google-chrome" => {
            if cfg!(windows) {
                PathBuf::from(app_data).join("Google\\Chrome\\User Data\\Default\\Network\\Cookies")
            } else if cfg!(target_os = "macos") {
                PathBuf::from(app_data).join("Google/Chrome/Default/Cookies")
            } else {
                PathBuf::from(app_data).join("google-chrome/Default/Cookies")
            }
        }
        "edge" | "msedge" => {
            if cfg!(windows) {
                PathBuf::from(app_data).join("Microsoft\\Edge\\User Data\\Default\\Network\\Cookies")
            } else if cfg!(target_os = "macos") {
                PathBuf::from(app_data).join("Microsoft Edge/Default/Cookies")
            } else {
                PathBuf::from(app_data).join("microsoft-edge/Default/Cookies")
            }
        }
        "firefox" => {
            // Firefox uses a different structure with profiles
            if cfg!(windows) {
                let roaming = env::var("APPDATA").context("APPDATA no est√° configurado")?;
                let profiles_dir = PathBuf::from(roaming).join("Mozilla\\Firefox\\Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else if cfg!(target_os = "macos") {
                let home = env::var("HOME").context("HOME no est√° configurado")?;
                let profiles_dir = PathBuf::from(home).join("Library/Application Support/Firefox/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else {
                let profiles_dir = PathBuf::from(app_data).join("firefox/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            }
        }
        "librewolf" => {
            // LibreWolf is a Firefox fork with different directory structure
            if cfg!(windows) {
                let roaming = env::var("APPDATA").context("APPDATA no est√° configurado")?;
                let profiles_dir = PathBuf::from(roaming).join("librewolf\\Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else if cfg!(target_os = "macos") {
                let home = env::var("HOME").context("HOME no est√° configurado")?;
                let profiles_dir = PathBuf::from(home).join("Library/Application Support/librewolf/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            } else {
                let profiles_dir = PathBuf::from(app_data).join("librewolf/Profiles");
                find_firefox_cookie_db(&profiles_dir)?
            }
        }
        "brave" => {
            if cfg!(windows) {
                PathBuf::from(app_data).join("BraveSoftware\\Brave-Browser\\User Data\\Default\\Network\\Cookies")
            } else {
                PathBuf::from(app_data).join("BraveSoftware/Brave-Browser/Default/Cookies")
            }
        }
        _ => {
            return Err(anyhow!(
                "Navegador no soportado: {}. Usa: chrome, firefox, librewolf, edge, brave",
                browser
            ))
        }
    };

    if !cookie_path.exists() {
        return Err(anyhow!(
            "No se encontr√≥ la base de datos de cookies en: {}\n\
            Aseg√∫rate de que:\n\
            ‚Ä¢ El navegador est√© instalado\n\
            ‚Ä¢ Has usado el navegador al menos una vez\n\
            ‚Ä¢ La ruta del perfil es correcta",
            cookie_path.display()
        ));
    }

    Ok(cookie_path)
}

/// Find Firefox cookie database (cookies.sqlite)
pub fn find_firefox_cookie_db(profiles_dir: &Path) -> Result<PathBuf> {
    let entries = fs::read_dir(profiles_dir)
            .with_context(|| format!("No se pudo leer el directorio de perfiles: {}", profiles_dir.display()))?;

    // Find the first .default or .default-release profile
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        if !path.is_dir() {
            continue;
        }

        let dir_name = match path.file_name() {
            Some(name) => name.to_string_lossy(),
            None => continue,
        };

        if dir_name.contains(".default") || dir_name.contains(".default-release") {
            let cookie_file = path.join("cookies.sqlite");
            if cookie_file.exists() {
                return Ok(cookie_file);
            }
        }
    }

    Err(anyhow!(
        "No se encontr√≥ 'cookies.sqlite' en ning√∫n perfil v√°lido dentro de: {}",
        profiles_dir.display()
    ))
}

/// Extract cookies from browser database
pub fn extract_cookies_from_db(db_path: &Path, domain: &str) -> Result<Vec<Cookie>> {
    // Create a temporary copy of the database because browsers lock it
    let temp_db = env::temp_dir().join(format!("msc_cookies_temp_{}.db", std::process::id()));

    // Copy main database file
    fs::copy(db_path, &temp_db).context("No se pudo copiar la base de datos de cookies. Aseg√∫rate de que el navegador est√© cerrado.")?;

    // Check for WAL (Write-Ahead Logging) files - these contain recent changes when browser is open
    let wal_path = db_path.with_extension("sqlite-wal");
    let shm_path = db_path.with_extension("sqlite-shm");

    let temp_wal = temp_db.with_extension("sqlite-wal");
    let temp_shm = temp_db.with_extension("sqlite-shm");

    // Copy WAL files if they exist (browser is open)
    if wal_path.exists() && fs::copy(&wal_path, &temp_wal).is_ok() {
        println!("{}", "   ‚ÑπÔ∏è  Navegador abierto detectado, leyendo archivo WAL...".yellow());
    }

    if shm_path.exists() {
        let _ = fs::copy(&shm_path, &temp_shm);
    }

    let conn = Connection::open(&temp_db)
        .context("No se pudo abrir la base de datos de cookies")?;

    let mut cookies = Vec::new();

    // Try Chrome/Edge/Brave schema first
    let chrome_query = "SELECT name, value, host_key, path, expires_utc, is_secure FROM cookies WHERE host_key LIKE ?1 OR host_key LIKE ?2 OR host_key = ?3";

    // Patterns for matching domains:
    // 1. .domain.com (subdomain wildcard)
    // 2. domain.com (exact match)
    // 3. www.domain.com (common www variant)
    
    let clean_domain = domain.strip_prefix("www.").unwrap_or(domain);

    let dot_domain_pattern = format!(".{}", clean_domain); 
    let exact_domain_pattern = clean_domain.to_string();  
    let www_domain_pattern = format!("www.{}", clean_domain);

    if let Ok(mut stmt) = conn.prepare(chrome_query) {
        let cookie_iter = stmt.query_map([&dot_domain_pattern, &exact_domain_pattern, &www_domain_pattern], |row| {
            Ok(Cookie {
                name: row.get(0)?,
                value: row.get(1)?,
                domain: row.get(2)?,
                path: row.get(3)?,
                expires: row.get(4)?,
                secure: row.get::<_, i64>(5)? != 0,
            })
        })?;

        for cookie in cookie_iter.flatten() {
            cookies.push(cookie);
        }
    } else {
        // Try Firefox schema - match .domain.com, domain.com, or www.domain.com
        let firefox_query = "SELECT name, value, host, path, expiry, isSecure FROM moz_cookies WHERE host = ?1 OR host = ?2 OR host = ?3";

        if let Ok(mut stmt) = conn.prepare(firefox_query) {
            let cookie_iter = stmt.query_map([&dot_domain_pattern, &exact_domain_pattern, &www_domain_pattern], |row| {
                Ok(Cookie {
                    name: row.get(0)?,
                    value: row.get(1)?,
                    domain: row.get(2)?,
                    path: row.get(3)?,
                    expires: row.get(4)?,
                    secure: row.get::<_, i64>(5)? != 0,
                })
            })?;

            for cookie in cookie_iter.flatten() {
                cookies.push(cookie);
            }

            // If no cookies found, try to debug by showing what hosts exist
            if cookies.is_empty() {
                eprintln!();
                eprintln!("{}", "üîç Debug: No se encontraron cookies con el patr√≥n de b√∫squeda.".yellow());
                eprintln!("{}", format!("   Buscando: '{}' o '{}'", exact_domain_pattern, dot_domain_pattern).dimmed());
                eprintln!();
                eprintln!("{}", "   Mostrando todos los hosts en la base de datos:".dimmed());

                if let Ok(mut stmt) = conn.prepare("SELECT DISTINCT host FROM moz_cookies LIMIT 20") {
                    let hosts: Vec<String> = stmt.query_map([], |row| row.get(0))?.flatten().collect();
                    for host in hosts {
                        eprintln!("     ‚Ä¢ {}", host.cyan());
                    }
                }
                eprintln!();
            }
        }
    }

    // Clean up temp files
    let _ = fs::remove_file(&temp_db);
    let _ = fs::remove_file(&temp_wal);
    let _ = fs::remove_file(&temp_shm);

    Ok(cookies)
}

/// Format cookies in different formats
pub fn format_cookies(cookies: &[Cookie], format: &str, _domain: &str) -> Result<String> {
    match format.to_lowercase().as_str() {
        "wget" => {
            // Format: name1=value1; name2=value2
            let cookie_pairs: Vec<String> = cookies
                .iter()
                .map(|c| format!("{}={}", c.name, c.value))
                .collect();
            Ok(cookie_pairs.join("; "))
        }
        "json" => {
            // Format as JSON array
            let json = serde_json::to_string_pretty(
                &cookies
                    .iter()
                    .map(|c| {
                        serde_json::json!({
                            "name": c.name,
                            "value": c.value,
                            "domain": c.domain,
                            "path": c.path,
                            "expires": c.expires,
                            "secure": c.secure,
                        })
                    })
                    .collect::<Vec<_>>(),
            )?;
            Ok(json)
        }
        "netscape" => {
            // Netscape cookie file format
            let mut output = String::new();
            output.push_str("# Netscape HTTP Cookie File\n");
            output.push_str("# This file was generated by msc\n\n");

            for cookie in cookies {
                let secure_flag = if cookie.secure { "TRUE" } else { "FALSE" };
                let domain_flag = if cookie.domain.starts_with('.') {
                    "TRUE"
                } else {
                    "FALSE"
                };

                output.push_str(&format!(
                    "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
                    cookie.domain,
                    domain_flag,
                    cookie.path,
                    secure_flag,
                    cookie.expires,
                    cookie.name,
                    cookie.value
                ));
            }

            Ok(output)
        }
        _ => Err(anyhow!(
            "Formato no soportado: {}. Usa: wget, json, netscape",
            format
        )),
    }
}

/// Debug database information - shows schema and sample data
pub fn debug_database_info(db_path: &Path) -> Result<()> {
    println!("{}", "üîç INFORMACI√ìN DE LA BASE DE DATOS".cyan().bold());
    println!("{}", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".cyan());
    println!();

    // Create temporary copy
    let temp_db = env::temp_dir().join(format!("msc_debug_{}.db", std::process::id()));
    fs::copy(db_path, &temp_db)?;

    // Copy WAL files if they exist
    let wal_path = db_path.with_extension("sqlite-wal");
    let shm_path = db_path.with_extension("sqlite-shm");
    let temp_wal = temp_db.with_extension("sqlite-wal");
    let temp_shm = temp_db.with_extension("sqlite-shm");

    if wal_path.exists() {
        let _ = fs::copy(&wal_path, &temp_wal);
    }
    if shm_path.exists() {
        let _ = fs::copy(&shm_path, &temp_shm);
    }

    let conn = Connection::open(&temp_db)?;

    // 1. List all tables
    println!("{}", "üìä TABLAS EN LA BASE DE DATOS:".green().bold());
    let mut stmt = conn.prepare("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")?;
    let tables: Vec<String> = stmt
        .query_map([], |row| row.get(0))?
        .flatten()
        .collect();

    for table in &tables {
        println!("   ‚Ä¢ {}", table.cyan());
    }
    println!();

    // 2. Find cookie-related tables
    let cookie_tables: Vec<&String> = tables
        .iter()
        .filter(|t| t.to_lowercase().contains("cookie"))
        .collect();

    if cookie_tables.is_empty() {
        println!("{}", "‚ö†Ô∏è  No se encontraron tablas relacionadas con cookies".yellow());
        println!();
    } else {
        for table_name in cookie_tables {
            println!("{} {}", "üìã ESQUEMA DE LA TABLA:".green().bold(), table_name.cyan());

            // Get table schema
            let mut stmt = conn.prepare(&format!("PRAGMA table_info({})", table_name))?;
            let columns: Vec<(i32, String, String)> = stmt
                .query_map([], |row| {
                    Ok((row.get(0)?, row.get(1)?, row.get(2)?))
                })?
                .flatten()
                .collect();

            println!("{}", "   Columnas:".dimmed());
            for (_, col_name, col_type) in &columns {
                println!("   ‚Ä¢ {} ({})", col_name.cyan(), col_type.dimmed());
            }
            println!();

            // Count total rows
            let count: i64 = conn.query_row(&format!("SELECT COUNT(*) FROM {}", table_name), [], |row| {
                row.get(0)
            })?;
            println!("{} {}", "   Total de filas:".dimmed(), count.to_string().yellow());
            println!();

            // Show sample data (first 5 rows)
            if count > 0 {
                println!("{}", "   üìù MUESTRA DE DATOS (primeras 5 filas):".dimmed());
                let column_names: Vec<String> = columns.iter().map(|(_, name, _)| name.clone()).collect();

                let query = format!("SELECT * FROM {} LIMIT 5", table_name);
                let mut stmt = conn.prepare(&query)?;

                let mut rows = stmt.query([])?;
                let mut row_num = 1;

                while let Some(row) = rows.next()? {
                    println!();
                    println!("   {} {}", "Fila".dimmed(), row_num.to_string().yellow());
                    for (i, col_name) in column_names.iter().enumerate() {
                        let value: Result<String, _> = row.get(i);
                        let display_value = match value {
                            Ok(v) => {
                                if v.len() > 50 {
                                    format!("{}... ({} chars)", &v[..50], v.len())
                                } else {
                                    v
                                }
                            }
                            Err(_) => {
                                // Try as integer
                                if let Ok(v) = row.get::<_, i64>(i) {
                                    v.to_string()
                                } else {
                                    "<NULL>".to_string()
                                }
                            }
                        };
                        println!("     {}: {}", col_name.cyan(), display_value);
                    }
                    row_num += 1;
                }
                println!();
            }

            // Show some specific domain queries
            println!("{}", "   üîç B√öSQUEDA DE DOMINIOS POPULARES:".dimmed());
            let test_domains = vec!["google", "youtube", "github"];

            for test_domain in test_domains {
                // Try different column names
                let queries = vec![
                    format!("SELECT COUNT(*) FROM {} WHERE host LIKE '%{}%'", table_name, test_domain),
                    format!("SELECT COUNT(*) FROM {} WHERE host_key LIKE '%{}%'", table_name, test_domain),
                    format!("SELECT COUNT(*) FROM {} WHERE domain LIKE '%{}%'", table_name, test_domain),
                ];

                for query in queries {
                    if let Ok(count) = conn.query_row(&query, [], |row| row.get::<_, i64>(0)) {
                        if count > 0 {
                            println!("     ‚Ä¢ {}: {} cookies", test_domain.yellow(), count.to_string().green());
                            break;
                        }
                    }
                }
            }
            println!();
        }
    }

    // Clean up
    let _ = fs::remove_file(&temp_db);
    let _ = fs::remove_file(&temp_wal);
    let _ = fs::remove_file(&temp_shm);

    println!("{}", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ".cyan());
    println!();

    Ok(())
}

pub fn resolve_cookie_path(url: &str, cookies: Option<&str>) -> Result<Option<PathBuf>> {
    match cookies {
        Some(cookie_input) => {
            let path = PathBuf::from(cookie_input);
            if path.exists() && path.is_file() {
                println!("{} {}", "üç™ Cookies:".cyan(), "Archivo local cargado".green());
                Ok(Some(path))
            } else {
                // Asumimos que create_cookie_file existe en tu contexto
                let url_parsed = Url::parse(url).context("URL inv√°lida para cookies")?;
                let file = create_cookie_file(&url_parsed, cookie_input)?; 
                println!("{} {}", "üç™ Cookies:".cyan(), "String configurado temporalmente".green());
                Ok(Some(file))
            }
        }
        None => Ok(None),
    }
}