use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

use super::alias::Alias;

/// Trait for generating alias executables
pub trait AliasGenerator {
    /// Generate an executable for an alias
    fn generate(&self, alias: &Alias, output_path: &Path) -> Result<()>;

    /// Clean up an alias executable
    fn cleanup(&self, alias_name: &str, output_path: &Path) -> Result<()>;
}

/// Windows executable shim generator
pub struct WindowsExeGenerator {
    shim_source: PathBuf,
}

impl WindowsExeGenerator {
    pub fn new() -> Result<Self> {
        let shim_source = Self::get_shim_path()?;
        Self::ensure_shim_exists(&shim_source)?;

        Ok(Self { shim_source })
    }

    /// Get the path where the shim executable is stored
    fn get_shim_path() -> Result<PathBuf> {
        let config_dir =
            dirs::config_dir().with_context(|| "Could not determine config directory")?;

        Ok(config_dir.join("msc").join("aliases").join("msc-shim.exe"))
    }

    /// Ensure the shim executable exists, extract it if needed
    fn ensure_shim_exists(shim_path: &Path) -> Result<()> {
        if shim_path.exists() {
            return Ok(());
        }

        // Create parent directory
        if let Some(parent) = shim_path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create directory: {:?}", parent))?;
        }

        // Extract embedded shim
        // The build.rs script compiles msc-shim and embeds it
        #[cfg(target_os = "windows")]
        let shim_bytes = include_bytes!(concat!(env!("OUT_DIR"), "/msc-shim.exe"));

        #[cfg(not(target_os = "windows"))]
        let shim_bytes = include_bytes!(concat!(env!("OUT_DIR"), "/msc-shim"));

        fs::write(shim_path, shim_bytes)
            .with_context(|| format!("Failed to write shim to {:?}", shim_path))?;

        Ok(())
    }
}

impl AliasGenerator for WindowsExeGenerator {
    fn generate(&self, alias: &Alias, output_path: &Path) -> Result<()> {
        let target_path = output_path.join(format!("{}.exe", alias.name));

        // Copy the shim executable
        fs::copy(&self.shim_source, &target_path).with_context(|| {
            format!(
                "Failed to copy shim from {:?} to {:?}",
                self.shim_source, target_path
            )
        })?;

        Ok(())
    }

    fn cleanup(&self, alias_name: &str, output_path: &Path) -> Result<()> {
        let target_path = output_path.join(format!("{}.exe", alias_name));

        if target_path.exists() {
            fs::remove_file(&target_path)
                .with_context(|| format!("Failed to remove {:?}", target_path))?;
        }

        Ok(())
    }
}

/// Unix shell script generator
#[derive(Default)]
pub struct UnixScriptGenerator;

impl UnixScriptGenerator {
    pub fn new() -> Self {
        Self
    }
}

impl AliasGenerator for UnixScriptGenerator {
    fn generate(&self, alias: &Alias, output_path: &Path) -> Result<()> {
        let target_path = output_path.join(&alias.name);

        // Create shell script
        let script = format!(
            "#!/bin/bash\n# Generated by msc - Alias: {}\nexec {} \"$@\"\n",
            alias.name, alias.command
        );

        fs::write(&target_path, script)
            .with_context(|| format!("Failed to write script to {:?}", target_path))?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&target_path)?.permissions();
            perms.set_mode(0o755); // rwxr-xr-x
            fs::set_permissions(&target_path, perms)?;
        }

        Ok(())
    }

    fn cleanup(&self, alias_name: &str, output_path: &Path) -> Result<()> {
        let target_path = output_path.join(alias_name);

        if target_path.exists() {
            fs::remove_file(&target_path)
                .with_context(|| format!("Failed to remove {:?}", target_path))?;
        }

        Ok(())
    }
}

/// Get the appropriate generator for the current platform
pub fn get_generator() -> Result<Box<dyn AliasGenerator>> {
    #[cfg(windows)]
    return Ok(Box::new(WindowsExeGenerator::new()?));

    #[cfg(unix)]
    return Ok(Box::new(UnixScriptGenerator::new()));

    #[cfg(not(any(windows, unix)))]
    anyhow::bail!("Unsupported platform");
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_unix_script_generation() {
        let generator = UnixScriptGenerator::new();
        let temp_dir = tempdir().unwrap();

        let alias = Alias::new("test".to_string(), "echo 'hello'".to_string());

        generator.generate(&alias, temp_dir.path()).unwrap();

        let script_path = temp_dir.path().join("test");
        assert!(script_path.exists());

        let content = fs::read_to_string(&script_path).unwrap();
        assert!(content.contains("#!/bin/bash"));
        assert!(content.contains("echo 'hello'"));
    }

    #[test]
    fn test_cleanup() {
        let generator = UnixScriptGenerator::new();
        let temp_dir = tempdir().unwrap();

        let alias = Alias::new("test".to_string(), "echo 'hello'".to_string());

        generator.generate(&alias, temp_dir.path()).unwrap();
        generator.cleanup("test", temp_dir.path()).unwrap();

        let script_path = temp_dir.path().join("test");
        assert!(!script_path.exists());
    }
}
