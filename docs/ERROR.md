  Ã— /home/runner/work/msc/msc/.github/workflows/release.yml has out of date contents and needs to be regenerated:
  â”‚ --- /home/runner/work/msc/msc/.github/workflows/release.yml
  â”‚ +++ /home/runner/work/msc/msc/.github/workflows/release.yml
  â”‚ @@ -1,187 +1,296 @@
  â”‚ +# This file was autogenerated by dist: https://axodotdev.github.io/cargo-dist
  â”‚ +#
  â”‚ +# Copyright 2022-2024, axodotdev
  â”‚ +# SPDX-License-Identifier: MIT or Apache-2.0
  â”‚ +#
  â”‚ +# CI that:
  â”‚ +#
  â”‚ +# * checks for a Git Tag that looks like a release
  â”‚ +# * builds artifacts with dist (archives, installers, hashes)
  â”‚ +# * uploads those artifacts to temporary workflow zip
  â”‚ +# * on success, uploads the artifacts to a GitHub Release
  â”‚ +#
  â”‚ +# Note that the GitHub Release will be created with a generated
  â”‚ +# title/body based on your changelogs.
  â”‚ +
  â”‚  name: Release
  â”‚ -
  â”‚  permissions:
  â”‚ -  contents: read
  â”‚ +  "contents": "write"
  â”‚ 
  â”‚ +# This task will run whenever you push a git tag that looks like a version
  â”‚ +# like "1.0.0", "v0.1.0-prerelease.1", "my-app/0.1.0", "releases/v1.0.0", etc.
  â”‚ +# Various formats will be parsed into a VERSION and an optional PACKAGE_NAME, where
  â”‚ +# PACKAGE_NAME must be the name of a Cargo package in your workspace, and VERSION
  â”‚ +# must be a Cargo-style SemVer Version (must have at least major.minor.patch).
  â”‚ +#
  â”‚ +# If PACKAGE_NAME is specified, then the announcement will be for that
  â”‚ +# package (erroring out if it doesn't have the given version or isn't dist-able).
  â”‚ +#
  â”‚ +# If PACKAGE_NAME isn't specified, then the announcement will be for all
  â”‚ +# (dist-able) packages in the workspace with that version (this mode is
  â”‚ +# intended for workspaces with only one dist-able package, or with all dist-able
  â”‚ +# packages versioned/released in lockstep).
  â”‚ +#
  â”‚ +# If you push multiple tags at once, separate instances of this workflow will
  â”‚ +# spin up, creating an independent announcement for each one. However, GitHub
  â”‚ +# will hard limit this to 3 tags per commit, as it will assume more tags is a
  â”‚ +# mistake.
  â”‚ +#
  â”‚ +# If there's a prerelease-style suffix to the version, then the release(s)
  â”‚ +# will be marked as a prerelease.
  â”‚  on:
  â”‚ +  pull_request:
  â”‚    push:
  â”‚ -    branches: [main]
  â”‚ -    paths:
  â”‚ -      - 'Cargo.toml'
  â”‚ -      - 'src/**'
  â”‚ -  workflow_dispatch:
  â”‚ -    inputs:
  â”‚ -      force:
  â”‚ -        description: 'Force release with timestamp'
  â”‚ -        type: boolean
  â”‚ -        default: false
  â”‚ +    tags:
  â”‚ +      - '**[0-9]+.[0-9]+.[0-9]+*'
  â”‚ 
  â”‚  jobs:
  â”‚ -  create-tag:
  â”‚ -    runs-on: ubuntu-latest
  â”‚ -    permissions:
  â”‚ -      contents: write
  â”‚ -    outputs:
  â”‚ -      tag: ${{ steps.create_tag.outputs.tag }}
  â”‚ -      should_release: ${{ steps.check.outputs.should_release }}
  â”‚ -    steps:
  â”‚ -      - uses: actions/checkout@v4
  â”‚ -        with:
  â”‚ -          fetch-depth: 0
  â”‚ -
  â”‚ -      - name: Extract version
  â”‚ -        id: version
  â”‚ -        run: |
  â”‚ -          VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
  â”‚ -          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
  â”‚ -          echo "ðŸ“¦ Detected version: $VERSION"
  â”‚ -
  â”‚ -      - name: Check tag
  â”‚ -        id: check
  â”‚ -        run: |
  â”‚ -          VERSION="${{ steps.version.outputs.version }}"
  â”‚ -          TAG="v$VERSION"
  â”‚ -
  â”‚ -          if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
  â”‚ -            if [[ "${{ github.event.inputs.force }}" == "true" ]]; then
  â”‚ -              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
  â”‚ -              TAG="v${VERSION}+${TIMESTAMP}"
  â”‚ -              echo "should_release=true" >> "$GITHUB_OUTPUT"
  â”‚ -            else
  â”‚ -              echo "should_release=false" >> "$GITHUB_OUTPUT"
  â”‚ -            fi
  â”‚ -          else
  â”‚ -            echo "should_release=true" >> "$GITHUB_OUTPUT"
  â”‚ -          fi
  â”‚ -
  â”‚ -          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
  â”‚ -          echo "ðŸ·ï¸ Tag: $TAG"
  â”‚ -
  â”‚ -      - name: Create tag
  â”‚ -        id: create_tag
  â”‚ -        if: steps.check.outputs.should_release == 'true'
  â”‚ -        run: |
  â”‚ -          TAG="${{ steps.check.outputs.tag }}"
  â”‚ -          git config user.name "github-actions[bot]"
  â”‚ -          git config user.email "github-actions[bot]@users.noreply.github.com"
  â”‚ -          git tag -a "$TAG" -m "Release $TAG"
  â”‚ -          git push origin "$TAG"
  â”‚ -          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
  â”‚ -
  â”‚ +  # Run 'dist plan' (or host) to determine what tasks we need to do
  â”‚    plan:
  â”‚ -    needs: create-tag
  â”‚ -    if: needs.create-tag.outputs.should_release == 'true'
  â”‚ -    runs-on: ubuntu-latest
  â”‚ +    runs-on: "ubuntu-22.04"
  â”‚      outputs:
  â”‚ -      has-artifacts: ${{ steps.plan.outputs.has-artifacts }}
  â”‚ -      manifest: ${{ steps.plan.outputs.manifest }}
  â”‚ +      val: ${{ steps.plan.outputs.manifest }}
  â”‚ +      tag: ${{ !github.event.pull_request && github.ref_name || '' }}
  â”‚ +      tag-flag: ${{ !github.event.pull_request && format('--tag={0}', github.ref_name) || '' }}
  â”‚ +      publishing: ${{ !github.event.pull_request }}
  â”‚      env:
  â”‚        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  â”‚ -
  â”‚      steps:
  â”‚        - uses: actions/checkout@v4
  â”‚          with:
  â”‚ -          ref: ${{ needs.create-tag.outputs.tag }}
  â”‚ -
  â”‚ -      - name: Install cargo-dist
  â”‚ -        run: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/
  â”‚ v0.30.3/cargo-dist-installer.sh | sh
  â”‚ -
  â”‚ +          persist-credentials: false
  â”‚ +          submodules: recursive
  â”‚ +      - name: Install dist
  â”‚ +        # we specify bash to get pipefail; it guards against the `curl` command
  â”‚ +        # failing. otherwise `sh` won't catch that `curl` returned non-0
  â”‚ +        shell: bash
  â”‚ +        run: "curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/
  â”‚ v0.30.3/cargo-dist-installer.sh | sh"
  â”‚        - name: Cache dist
  â”‚          uses: actions/upload-artifact@v4
  â”‚          with:
  â”‚            name: cargo-dist-cache
  â”‚            path: ~/.cargo/bin/dist
  â”‚ -
  â”‚ -      - name: Plan
  â”‚ -        id: plan
  â”‚ +      # sure would be cool if github gave us proper conditionals...
  â”‚ +      # so here's a doubly-nested ternary-via-truthiness to try to provide the best possible
  â”‚ +      # functionality based on whether this is a pull_request, and whether it's from a fork.
  â”‚ +      # (PRs run on the *source* but secrets are usually on the *target* -- that's *good*
  â”‚ +      # but also really annoying to build CI around when it needs secrets to work right.)
  â”‚ +      - id: plan
  â”‚          run: |
  â”‚ -          dist host --steps=create --tag=${{ needs.create-tag.outputs.tag }} --output-format=json > plan.json
  â”‚ -          cat plan.json
  â”‚ -          echo "manifest=$(jq -c '.' plan.json)" >> "$GITHUB_OUTPUT"
  â”‚ -          echo "has-artifacts=true" >> "$GITHUB_OUTPUT"
  â”‚ -
  â”‚ -      - name: Upload plan
  â”‚ +          dist ${{ (!github.event.pull_request && format('host --steps=create --tag={0}', github.ref_name)) ||
  â”‚ 'plan' }} --output-format=json > plan-dist-manifest.json
  â”‚ +          echo "dist ran successfully"
  â”‚ +          cat plan-dist-manifest.json
  â”‚ +          echo "manifest=$(jq -c "." plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"
  â”‚ +      - name: "Upload dist-manifest.json"
  â”‚          uses: actions/upload-artifact@v4
  â”‚          with:
  â”‚ -          name: artifacts-plan
  â”‚ -          path: plan.json
  â”‚ +          name: artifacts-plan-dist-manifest
  â”‚ +          path: plan-dist-manifest.json
  â”‚ 
  â”‚ -  build:
  â”‚ -    needs: [create-tag, plan]
  â”‚ -    if: needs.plan.outputs.has-artifacts == 'true'
  â”‚ +  # Build and packages all the platform-specific things
  â”‚ +  build-local-artifacts:
  â”‚ +    name: build-local-artifacts (${{ join(matrix.targets, ', ') }})
  â”‚ +    # Let the initial task tell us to not run (currently very blunt)
  â”‚ +    needs:
  â”‚ +      - plan
  â”‚ +    if: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null &&
  â”‚ (needs.plan.outputs.publishing == 'true' || fromJson(needs.plan.outputs.val).ci.github.pr_run_mode == 'upload') }}
  â”‚      strategy:
  â”‚        fail-fast: false
  â”‚ -      matrix: ${{ fromJson(needs.plan.outputs.manifest).ci.github.artifacts_matrix }}
  â”‚ +      # Target platforms/runners are computed by dist in create-release.
  â”‚ +      # Each member of the matrix has the following arguments:
  â”‚ +      #
  â”‚ +      # - runner: the github runner
  â”‚ +      # - dist-args: cli flags to pass to dist
  â”‚ +      # - install-dist: expression to run to install dist on the runner
  â”‚ +      #
  â”‚ +      # Typically there will be:
  â”‚ +      # - 1 "global" task that builds universal installers
  â”‚ +      # - N "local" tasks that build each platform's binaries and platform-specific installers
  â”‚ +      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}
  â”‚      runs-on: ${{ matrix.runner }}
  â”‚ +    container: ${{ matrix.container && matrix.container.image || null }}
  â”‚      env:
  â”‚        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  â”‚ +      BUILD_MANIFEST_NAME: target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json
  â”‚      steps:
  â”‚ +      - name: enable windows longpaths
  â”‚ +        run: |
  â”‚ +          git config --global core.longpaths true
  â”‚        - uses: actions/checkout@v4
  â”‚          with:
  â”‚ -          ref: ${{ needs.create-tag.outputs.tag }}
  â”‚ -
  â”‚ +          persist-credentials: false
  â”‚ +          submodules: recursive
  â”‚ +      - name: Install Rust non-interactively if not already installed
  â”‚ +        if: ${{ matrix.container }}
  â”‚ +        run: |
  â”‚ +          if ! command -v cargo > /dev/null 2>&1; then
  â”‚ +            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
  â”‚ +            echo "$HOME/.cargo/bin" >> $GITHUB_PATH
  â”‚ +          fi
  â”‚        - name: Install dist
  â”‚          run: ${{ matrix.install_dist.run }}
  â”‚ +      # Get the dist-manifest
  â”‚ +      - name: Fetch local artifacts
  â”‚ +        uses: actions/download-artifact@v4
  â”‚ +        with:
  â”‚ +          pattern: artifacts-*
  â”‚ +          path: target/distrib/
  â”‚ +          merge-multiple: true
  â”‚ +      - name: Install dependencies
  â”‚ +        run: |
  â”‚ +          ${{ matrix.packages_install }}
  â”‚ +      - name: Build artifacts
  â”‚ +        run: |
  â”‚ +          # Actually do builds and make zips and whatnot
  â”‚ +          dist build ${{ needs.plan.outputs.tag-flag }} --print=linkage --output-format=json
  â”‚ ${{ matrix.dist_args }} > dist-manifest.json
  â”‚ +          echo "dist ran successfully"
  â”‚ +      - id: cargo-dist
  â”‚ +        name: Post-build
  â”‚ +        # We force bash here just because github makes it really hard to get values up
  â”‚ +        # to "real" actions without writing to env-vars, and writing to env-vars has
  â”‚ +        # inconsistent syntax between shell and powershell.
  â”‚ +        shell: bash
  â”‚ +        run: |
  â”‚ +          # Parse out what we just built and upload it to scratch storage
  â”‚ +          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
  â”‚ +          dist print-upload-files-from-manifest --manifest dist-manifest.json >> "$GITHUB_OUTPUT"
  â”‚ +          echo "EOF" >> "$GITHUB_OUTPUT"
  â”‚ +
  â”‚ +          cp dist-manifest.json "$BUILD_MANIFEST_NAME"
  â”‚ +      - name: "Upload artifacts"
  â”‚ +        uses: actions/upload-artifact@v4
  â”‚ +        with:
  â”‚ +          name: artifacts-build-local-${{ join(matrix.targets, '_') }}
  â”‚ +          path: |
  â”‚ +            ${{ steps.cargo-dist.outputs.paths }}
  â”‚ +            ${{ env.BUILD_MANIFEST_NAME }}
  â”‚ 
  â”‚ -      - name: Download plan
  â”‚ +  # Build and package all the platform-agnostic(ish) things
  â”‚ +  build-global-artifacts:
  â”‚ +    needs:
  â”‚ +      - plan
  â”‚ +      - build-local-artifacts
  â”‚ +    runs-on: "ubuntu-22.04"
  â”‚ +    env:
  â”‚ +      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  â”‚ +      BUILD_MANIFEST_NAME: target/distrib/global-dist-manifest.json
  â”‚ +    steps:
  â”‚ +      - uses: actions/checkout@v4
  â”‚ +        with:
  â”‚ +          persist-credentials: false
  â”‚ +          submodules: recursive
  â”‚ +      - name: Install cached dist
  â”‚ +        uses: actions/download-artifact@v4
  â”‚ +        with:
  â”‚ +          name: cargo-dist-cache
  â”‚ +          path: ~/.cargo/bin/
  â”‚ +      - run: chmod +x ~/.cargo/bin/dist
  â”‚ +      # Get all the local artifacts for the global tasks to use (for e.g. checksums)
  â”‚ +      - name: Fetch local artifacts
  â”‚          uses: actions/download-artifact@v4
  â”‚          with:
  â”‚            pattern: artifacts-*
  â”‚            path: target/distrib/
  â”‚            merge-multiple: true
  â”‚ +      - id: cargo-dist
  â”‚ +        shell: bash
  â”‚ +        run: |
  â”‚ +          dist build ${{ needs.plan.outputs.tag-flag }} --output-format=json "--artifacts=global" > dist-
  â”‚ manifest.json
  â”‚ +          echo "dist ran successfully"
  â”‚ 
  â”‚ -      - name: Build
  â”‚ -        run: dist build --tag=${{ needs.create-tag.outputs.tag }} --output-format=json ${{ matrix.dist_args }} >
  â”‚ build.json
  â”‚ +          # Parse out what we just built and upload it to scratch storage
  â”‚ +          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
  â”‚ +          jq --raw-output ".upload_files[]" dist-manifest.json >> "$GITHUB_OUTPUT"
  â”‚ +          echo "EOF" >> "$GITHUB_OUTPUT"
  â”‚ 
  â”‚ -      - name: Upload
  â”‚ +          cp dist-manifest.json "$BUILD_MANIFEST_NAME"
  â”‚ +      - name: "Upload artifacts"
  â”‚          uses: actions/upload-artifact@v4
  â”‚          with:
  â”‚ -          name: artifacts-${{ join(matrix.targets, '_') }}
  â”‚ +          name: artifacts-build-global
  â”‚            path: |
  â”‚ -            target/distrib/*
  â”‚ -            build.json
  â”‚ -
  â”‚ -  release:
  â”‚ -    needs: [create-tag, plan, build]
  â”‚ -    runs-on: ubuntu-latest
  â”‚ -    permissions:
  â”‚ -      contents: write
  â”‚ +            ${{ steps.cargo-dist.outputs.paths }}
  â”‚ +            ${{ env.BUILD_MANIFEST_NAME }}
  â”‚ +  # Determines if we should publish/announce
  â”‚ +  host:
  â”‚ +    needs:
  â”‚ +      - plan
  â”‚ +      - build-local-artifacts
  â”‚ +      - build-global-artifacts
  â”‚ +    # Only run if we're "publishing", and only if plan, local and global didn't fail (skipped is fine)
  â”‚ +    if: ${{ always() && needs.plan.result == 'success' && needs.plan.outputs.publishing == 'true' &&
  â”‚ (needs.build-global-artifacts.result == 'skipped' || needs.build-global-artifacts.result == 'success') &&
  â”‚ (needs.build-local-artifacts.result == 'skipped' || needs.build-local-artifacts.result == 'success') }}
  â”‚      env:
  â”‚        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  â”‚ +    runs-on: "ubuntu-22.04"
  â”‚ +    outputs:
  â”‚ +      val: ${{ steps.host.outputs.manifest }}
  â”‚      steps:
  â”‚        - uses: actions/checkout@v4
  â”‚          with:
  â”‚ -          ref: ${{ needs.create-tag.outputs.tag }}
  â”‚ -
  â”‚ -      - name: Download dist
  â”‚ +          persist-credentials: false
  â”‚ +          submodules: recursive
  â”‚ +      - name: Install cached dist
  â”‚          uses: actions/download-artifact@v4
  â”‚          with:
  â”‚            name: cargo-dist-cache
  â”‚            path: ~/.cargo/bin/
  â”‚ -
  â”‚        - run: chmod +x ~/.cargo/bin/dist
  â”‚ -
  â”‚ -      - name: Download artifacts
  â”‚ +      # Fetch artifacts from scratch-storage
  â”‚ +      - name: Fetch artifacts
  â”‚          uses: actions/download-artifact@v4
  â”‚          with:
  â”‚            pattern: artifacts-*
  â”‚            path: target/distrib/
  â”‚            merge-multiple: true
  â”‚ -
  â”‚ -      - name: Publish
  â”‚ +      - id: host
  â”‚ +        shell: bash
  â”‚          run: |
  â”‚ -          dist host --tag=${{ needs.create-tag.outputs.tag }} --steps=upload --steps=release --output-format=json
  â”‚ > release.json
  â”‚ -          cat release.json
  â”‚ -
  â”‚ -      - name: Upload manifest
  â”‚ +          dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json >
  â”‚ dist-manifest.json
  â”‚ +          echo "artifacts uploaded and released successfully"
  â”‚ +          cat dist-manifest.json
  â”‚ +          echo "manifest=$(jq -c "." dist-manifest.json)" >> "$GITHUB_OUTPUT"
  â”‚ +      - name: "Upload dist-manifest.json"
  â”‚          uses: actions/upload-artifact@v4
  â”‚          with:
  â”‚ -          name: release-manifest
  â”‚ -          path: release.json
  â”‚ +          # Overwrite the previous copy
  â”‚ +          name: artifacts-dist-manifest
  â”‚ +          path: dist-manifest.json
  â”‚ +      # Create a GitHub Release while uploading all files to it
  â”‚ +      - name: "Download GitHub Artifacts"
  â”‚ +        uses: actions/download-artifact@v4
  â”‚ +        with:
  â”‚ +          pattern: artifacts-*
  â”‚ +          path: artifacts
  â”‚ +          merge-multiple: true
  â”‚ +      - name: Cleanup
  â”‚ +        run: |
  â”‚ +          # Remove the granular manifests
  â”‚ +          rm -f artifacts/*-dist-manifest.json
  â”‚ +      - name: Create GitHub Release
  â”‚ +        env:
  â”‚ +          PRERELEASE_FLAG: "${{ fromJson(steps.host.outputs.manifest).announcement_is_prerelease &&
  â”‚ '--prerelease' || '' }}"
  â”‚ +          ANNOUNCEMENT_TITLE: "${{ fromJson(steps.host.outputs.manifest).announcement_title }}"
  â”‚ +          ANNOUNCEMENT_BODY: "${{ fromJson(steps.host.outputs.manifest).announcement_github_body }}"
  â”‚ +          RELEASE_COMMIT: "${{ github.sha }}"
  â”‚ +        run: |
  â”‚ +          # Write and read notes from a file to avoid quoting breaking things
  â”‚ +          echo "$ANNOUNCEMENT_BODY" > $RUNNER_TEMP/notes.txt
  â”‚ +
  â”‚ +          gh release create "${{ needs.plan.outputs.tag }}" --target "$RELEASE_COMMIT" $PRERELEASE_FLAG --title
  â”‚ "$ANNOUNCEMENT_TITLE" --notes-file "$RUNNER_TEMP/notes.txt" artifacts/*
  â”‚ 
  â”‚    announce:
  â”‚ -    needs: [create-tag, release]
  â”‚ -    if: success()
  â”‚ -    runs-on: ubuntu-latest
  â”‚ +    needs:
  â”‚ +      - plan
  â”‚ +      - host
  â”‚ +    # use "always() && ..." to allow us to wait for all publish jobs while
  â”‚ +    # still allowing individual publish jobs to skip themselves (for prereleases).
  â”‚ +    # "host" however must run to completion, no skipping allowed!
  â”‚ +    if: ${{ always() && needs.host.result == 'success' }}
  â”‚ +    runs-on: "ubuntu-22.04"
  â”‚ +    env:
  â”‚ +      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  â”‚      steps:
  â”‚ -      - run: echo "ðŸŽ‰ Release ${{ needs.create-tag.outputs.tag }} published!"
  â”‚ +      - uses: actions/checkout@v4
  â”‚ +        with:
  â”‚ +          persist-credentials: false
  â”‚ +          submodules: recursive
  â”‚ 
  help: run 'dist init' to update the file
        ('allow-dirty' in Cargo.toml to ignore out of date contents)