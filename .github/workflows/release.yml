name: Release

permissions:
  contents: read

on:
  push:
    branches: [main]
    paths:
      - 'Cargo.toml'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force release with timestamp'
        type: boolean
        default: false

jobs:
  create-tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      tag: ${{ steps.create_tag.outputs.tag }}
      version: ${{ steps.create_tag.outputs.version }}
      should_release: ${{ steps.check.outputs.should_release }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Extract version
        id: version
        run: |
          VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "üì¶ Detected version: $VERSION"

      - name: Check version change
        id: check_version
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Get latest tag version
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          LATEST_VERSION=${LATEST_TAG#v}

          echo "üìä Current version: $VERSION"
          echo "üìä Latest tag version: $LATEST_VERSION"

          # Check if version changed or force is true
          if [[ "$VERSION" != "$LATEST_VERSION" ]] || [[ "${{ github.event.inputs.force }}" == "true" ]]; then
            echo "version_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "version_changed=false" >> "$GITHUB_OUTPUT"
            echo "‚è≠Ô∏è Version unchanged, skipping release"
          fi

      - name: Check tag
        id: check
        if: steps.check_version.outputs.version_changed == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="v$VERSION"

          if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
            if [[ "${{ github.event.inputs.force }}" == "true" ]]; then
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              TAG="v${VERSION}+${TIMESTAMP}"
              echo "should_release=true" >> "$GITHUB_OUTPUT"
            else
              echo "should_release=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "should_release=true" >> "$GITHUB_OUTPUT"
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "üè∑Ô∏è Tag: $TAG"

      - name: Create tag
        id: create_tag
        if: steps.check_version.outputs.version_changed == 'true' && steps.check.outputs.should_release == 'true'
        run: |
          TAG="${{ steps.check.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=${{ steps.version.outputs.version }}" >> "$GITHUB_OUTPUT"

  plan:
    needs: create-tag
    if: needs.create-tag.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    outputs:
      has-artifacts: ${{ steps.plan.outputs.has-artifacts }}
      manifest: ${{ steps.plan.outputs.manifest }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-tag.outputs.tag }}

      - name: Install cargo-dist
        run: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.30.3/cargo-dist-installer.sh | sh

      - name: Cache dist
        uses: actions/upload-artifact@v6
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/dist

      - name: Plan
        id: plan
        run: |
          dist host --steps=create --tag=${{ needs.create-tag.outputs.tag }} --output-format=json > plan.json
          cat plan.json
          echo "manifest=$(jq -c '.' plan.json)" >> "$GITHUB_OUTPUT"
          echo "has-artifacts=true" >> "$GITHUB_OUTPUT"

      - name: Upload plan
        uses: actions/upload-artifact@v6
        with:
          name: artifacts-plan
          path: plan.json

  build:
    needs: [create-tag, plan]
    if: needs.plan.outputs.has-artifacts == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.manifest).ci.github.artifacts_matrix }}
    runs-on: ${{ matrix.runner }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-tag.outputs.tag }}

      - name: Install dist
        run: ${{ matrix.install_dist.run }}

      - name: Download plan
        uses: actions/download-artifact@v7
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Build
        run: dist build --tag=${{ needs.create-tag.outputs.tag }} --output-format=json ${{ matrix.dist_args }} > build.json

      - name: Upload
        uses: actions/upload-artifact@v6
        with:
          name: artifacts-${{ join(matrix.targets, '_') }}
          path: |
            target/distrib/*
            build.json

  release:
    needs: [create-tag, plan, build]
    if: needs.create-tag.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-tag.outputs.tag }}
          fetch-depth: 0

      - name: Verify tag exists
        run: |
          TAG="${{ needs.create-tag.outputs.tag }}"
          echo "üîç Verifying tag: $TAG"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "‚úÖ Tag exists: $TAG"
            git show --no-patch --format="%H %ci %s" "$TAG"
          else
            echo "‚ùå Tag not found: $TAG"
            echo "Available tags:"
            git tag -l | tail -5
            exit 1
          fi

      - name: Download artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: artifacts-*
          path: artifacts/
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded artifacts:"
          find artifacts -type f || echo "No artifacts found"
          echo ""
          echo "üìä Artifact details:"
          ls -lah artifacts/ || echo "artifacts directory not found"

      - name: Debug context
        run: |
          echo "üîç Debug information:"
          echo "Tag: ${{ needs.create-tag.outputs.tag }}"
          echo "Version: ${{ needs.create-tag.outputs.version }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"

      - name: Create GitHub Release
        id: create-release
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const tag = '${{ needs.create-tag.outputs.tag }}';
            const version = '${{ needs.create-tag.outputs.version }}';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log(`üîç Debug info:`);
            console.log(`   Tag: ${tag}`);
            console.log(`   Version: ${version}`);
            console.log(`   Owner: ${owner}`);
            console.log(`   Repo: ${repo}`);
            console.log('');

            if (!tag || tag === 'undefined' || tag === '') {
              core.setFailed('‚ùå Tag is empty or undefined');
              return;
            }

            if (!version || version === 'undefined' || version === '') {
              core.setFailed('‚ùå Version is empty or undefined');
              return;
            }

            console.log(`üöÄ Creating release for tag: ${tag}`);

            try {
              // Try to create new release
              console.log('üìù Calling createRelease API...');
              const { data } = await github.rest.repos.createRelease({
                owner,
                repo,
                tag_name: tag,
                name: `MSC v${version}`,
                body: `## Release v${version}\n\nMulti-purpose CLI tool for system monitoring, media management, and productivity.\n\n### Installation\n\nSee [README.md](https://github.com/${owner}/${repo}#installation) for installation instructions.\n\n### Checksums\n\nSHA256 checksums are included for verification.`,
                draft: false,
                prerelease: false
              });

              core.setOutput('release_id', data.id);
              core.setOutput('upload_url', data.upload_url);
              console.log(`‚úÖ Created release: ${data.html_url}`);
              console.log(`   Release ID: ${data.id}`);

            } catch (e) {
              console.error(`‚ùå Error creating release: ${e.message}`);
              console.error(`   Status: ${e.status}`);
              console.error(`   Response: ${JSON.stringify(e.response?.data, null, 2)}`);

              if (e.status === 422) {
                console.log('‚ö†Ô∏è Release already exists (422), fetching existing release...');
                try {
                  const { data } = await github.rest.repos.getReleaseByTag({ owner, repo, tag_name: tag });
                  core.setOutput('release_id', data.id);
                  core.setOutput('upload_url', data.upload_url);
                  console.log(`‚úÖ Using existing release: ${data.html_url}`);
                  console.log(`   Release ID: ${data.id}`);
                } catch (fetchError) {
                  console.error(`‚ùå Failed to fetch existing release: ${fetchError.message}`);
                  throw fetchError;
                }
              } else {
                throw e;
              }
            }

      - name: Upload release artifacts
        run: |
          TAG="${{ needs.create-tag.outputs.tag }}"
          REPO="${{ github.repository }}"

          echo "üì§ Uploading artifacts to release $TAG"

          # Find all release artifacts (exclude build.json and plan.json)
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.zip" -o -name "*.msi" -o -name "*.sha256" -o -name "*.rb" \) | while read -r file; do
            filename=$(basename "$file")
            echo "  ‚¨ÜÔ∏è Uploading: $filename"
            gh release upload "$TAG" "$file" --repo "$REPO" --clobber || echo "‚ö†Ô∏è Failed to upload $filename"
          done

          echo "‚úÖ Upload completed"

      - name: Generate release manifest
        run: |
          echo '{
            "tag": "${{ needs.create-tag.outputs.tag }}",
            "version": "${{ needs.create-tag.outputs.version }}",
            "release_id": "${{ steps.create-release.outputs.release_id }}",
            "artifacts_uploaded": true
          }' > release.json

      - name: Upload manifest
        uses: actions/upload-artifact@v6
        with:
          name: release-manifest
          path: release.json

  update-packaging:
    needs: [create-tag, release]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Download release manifest
        uses: actions/download-artifact@v7
        with:
          name: release-manifest
          path: .

      - name: Extract release info
        id: release_info
        run: |
          VERSION="${{ needs.create-tag.outputs.version }}"
          TAG="${{ needs.create-tag.outputs.tag }}"

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

          # Get release URL
          RELEASE_URL="https://github.com/MarcossIC/msc/releases/download/$TAG"
          echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"

          echo "üì¶ Version: $VERSION"
          echo "üè∑Ô∏è Tag: $TAG"
          echo "üîó Release URL: $RELEASE_URL"

      - name: Download checksums
        run: |
          TAG="${{ needs.create-tag.outputs.tag }}"
          VERSION="${{ needs.create-tag.outputs.version }}"

          # Wait a bit for release to be fully available
          echo "‚è≥ Waiting 10 seconds for release to be available..."
          sleep 10

          # cargo-dist uses version without 'v' prefix in filenames
          echo "üì• Downloading checksums for version: $VERSION"
          curl -sL "https://github.com/MarcossIC/msc/releases/download/$TAG/msc-$VERSION-x86_64-pc-windows-msvc.msi.sha256" -o windows.sha256 || echo "‚ö†Ô∏è Windows checksum not found"
          curl -sL "https://github.com/MarcossIC/msc/releases/download/$TAG/msc-$VERSION-x86_64-unknown-linux-gnu.tar.xz.sha256" -o linux-x64.sha256 || echo "‚ö†Ô∏è Linux x64 checksum not found"
          curl -sL "https://github.com/MarcossIC/msc/releases/download/$TAG/msc-$VERSION-aarch64-unknown-linux-gnu.tar.xz.sha256" -o linux-arm64.sha256 || echo "‚ö†Ô∏è Linux ARM64 checksum not found"
          curl -sL "https://github.com/MarcossIC/msc/releases/download/$TAG/msc-$VERSION-x86_64-apple-darwin.tar.xz.sha256" -o macos-x64.sha256 || echo "‚ö†Ô∏è macOS x64 checksum not found"
          curl -sL "https://github.com/MarcossIC/msc/releases/download/$TAG/msc-$VERSION-aarch64-apple-darwin.tar.xz.sha256" -o macos-arm64.sha256 || echo "‚ö†Ô∏è macOS ARM64 checksum not found"

          # List downloaded files
          echo "üìã Downloaded files:"
          ls -lh *.sha256 2>/dev/null || echo "No checksums downloaded"

      - name: Update AUR PKGBUILD
        run: |
          VERSION="${{ steps.release_info.outputs.version }}"
          TAG="${{ steps.release_info.outputs.tag }}"

          if [ -f linux-x64.sha256 ]; then
            SHA256_X64=$(cat linux-x64.sha256 | awk '{print $1}')
          else
            SHA256_X64="REPLACE_WITH_SHA256_X86_64_LINUX"
          fi

          if [ -f linux-arm64.sha256 ]; then
            SHA256_ARM64=$(cat linux-arm64.sha256 | awk '{print $1}')
          else
            SHA256_ARM64="REPLACE_WITH_SHA256_ARM64_LINUX"
          fi

          sed -i "s/^pkgver=.*/pkgver=$VERSION/" packaging/aur/PKGBUILD
          sed -i "s/^pkgrel=.*/pkgrel=1/" packaging/aur/PKGBUILD
          sed -i "s|sha256sums_x86_64=.*|sha256sums_x86_64=('$SHA256_X64')|" packaging/aur/PKGBUILD
          sed -i "s|sha256sums_aarch64=.*|sha256sums_aarch64=('$SHA256_ARM64')|" packaging/aur/PKGBUILD

          echo "‚úÖ Updated AUR PKGBUILD"

      - name: Update winget manifest
        run: |
          VERSION="${{ steps.release_info.outputs.version }}"
          TAG="${{ steps.release_info.outputs.tag }}"
          RELEASE_URL="${{ steps.release_info.outputs.release_url }}"

          if [ -f windows.sha256 ]; then
            SHA256_WIN=$(cat windows.sha256 | awk '{print $1}')
          else
            SHA256_WIN="REPLACE_WITH_SHA256_FROM_RELEASE"
          fi

          # Update version in all manifests
          sed -i "s/^PackageVersion:.*/PackageVersion: $VERSION/" packaging/winget/MSC.yaml
          sed -i "s/^PackageVersion:.*/PackageVersion: $VERSION/" packaging/winget/MSC.installer.yaml
          sed -i "s/^PackageVersion:.*/PackageVersion: $VERSION/" packaging/winget/MSC.locale.en-US.yaml

          # Update installer URL and SHA256 (use VERSION not TAG in filename)
          sed -i "s|InstallerUrl:.*|InstallerUrl: $RELEASE_URL/msc-$VERSION-x86_64-pc-windows-msvc.msi|" packaging/winget/MSC.installer.yaml
          sed -i "s/InstallerSha256:.*/InstallerSha256: $SHA256_WIN/" packaging/winget/MSC.installer.yaml

          echo "‚úÖ Updated winget manifests"

      - name: Update Homebrew formula
        run: |
          VERSION="${{ steps.release_info.outputs.version }}"
          TAG="${{ steps.release_info.outputs.tag }}"
          RELEASE_URL="${{ steps.release_info.outputs.release_url }}"

          if [ -f macos-x64.sha256 ]; then
            SHA256_MACOS_X64=$(cat macos-x64.sha256 | awk '{print $1}')
          else
            SHA256_MACOS_X64="REPLACE_WITH_SHA256_X86_64_MACOS"
          fi

          if [ -f macos-arm64.sha256 ]; then
            SHA256_MACOS_ARM64=$(cat macos-arm64.sha256 | awk '{print $1}')
          else
            SHA256_MACOS_ARM64="REPLACE_WITH_SHA256_ARM64_MACOS"
          fi

          # Update Homebrew formula (use VERSION not TAG in filename)
          sed -i "s|url \".*\"|url \"$RELEASE_URL/msc-$VERSION-x86_64-apple-darwin.tar.xz\"|" packaging/homebrew/msc.rb
          sed -i "s/sha256 \".*\"/sha256 \"$SHA256_MACOS_X64\"/" packaging/homebrew/msc.rb
          sed -i "s/version \".*\"/version \"$VERSION\"/" packaging/homebrew/msc.rb

          echo "‚úÖ Updated Homebrew formula"

      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add packaging/

          if git diff --staged --quiet; then
            echo "üì≠ No changes to commit"
          else
            git commit -m "chore: update packaging manifests for v${{ steps.release_info.outputs.version }}

            - Update AUR PKGBUILD with new version and checksums
            - Update winget manifests with new version and checksums
            - Update Homebrew formula with new version and checksums

            Auto-generated by release workflow"

            git push origin main
            echo "‚úÖ Pushed packaging updates to main"
          fi

  cleanup:
    needs: [create-tag, update-packaging]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - uses: actions/checkout@v6

      - name: Cleanup temporary artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üßπ Cleaning up temporary workflow artifacts..."

          # Get the current run ID
          RUN_ID="${{ github.run_id }}"

          # List all artifacts for this run
          echo "üìã Current artifacts:"
          gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" --jq '.artifacts[] | "\(.name) (ID: \(.id))"'

          # Delete temporary artifacts (keep only if workflow failed for debugging)
          if [ "${{ needs.update-packaging.result }}" == "success" ]; then
            echo "‚úÖ Workflow succeeded, cleaning up all temporary artifacts..."

            # Delete build artifacts (already in release)
            gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
              --jq '.artifacts[] | select(.name | startswith("artifacts-")) | .id' \
              | xargs -I {} gh api -X DELETE "/repos/${{ github.repository }}/actions/artifacts/{}" || true

            # Delete cargo-dist cache
            gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
              --jq '.artifacts[] | select(.name == "cargo-dist-cache") | .id' \
              | xargs -I {} gh api -X DELETE "/repos/${{ github.repository }}/actions/artifacts/{}" || true

            # Delete release manifest
            gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
              --jq '.artifacts[] | select(.name == "release-manifest") | .id' \
              | xargs -I {} gh api -X DELETE "/repos/${{ github.repository }}/actions/artifacts/{}" || true

            echo "‚úÖ Cleanup completed"
          else
            echo "‚ö†Ô∏è Workflow had issues, keeping artifacts for debugging"
          fi

  announce:
    needs: [create-tag, update-packaging, cleanup]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - run: echo "üéâ Release ${{ needs.create-tag.outputs.tag }} published and packaging updated!"
